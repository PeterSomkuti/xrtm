/*******************************************************************************
 * Bindx2 interface definition file for XRTM
 ******************************************************************************/
prefix xrtm;

subprogram_init int 0 create				0, int 0 options in enum_mask xrtm_option_name_to_mask, int 0 solvers in enum_mask xrtm_solver_name_to_mask, int 0 max_coef in, int 0 n_quad in, int 0 n_stokes in, int 0 n_derivs in, int 0 n_layers in, int 0 n_theta_0s in, int 0 n_kernels in list_size, int 0 n_kernel_quad in, enum kernel_type 1 "n_kernels" kernels in enum_array xrtm_kernel_name_to_value, int 0 n_out_levels in, int 0 n_out_thetas in;
subprogram_free int 0 destroy				0;

subprogram_general int 0 get_options			1;
subprogram_general int 0 get_solvers			1;
subprogram_general int 0 get_max_coef			1;
subprogram_general int 0 get_n_quad			1;
subprogram_general int 0 get_n_stokes			1;
subprogram_general int 0 get_n_derivs			1;
subprogram_general int 0 get_n_layers			1;
subprogram_general int 0 get_n_kernels			1;
subprogram_general int 0 get_n_kernel_quad		1;
subprogram_general int 0 get_kernel			1, int 0 i_kernel in;
subprogram_general int 0 get_n_out_levels		1;
subprogram_general int 0 get_n_out_thetas		1;
subprogram_general int 0 set_doub_d_tau			0, double 0 d_tau in;
subprogram_general double 0 get_doub_d_tau		1;
subprogram_general int 0 set_pade_params 		0, int 0 pade_s in, int 0 pade_r in;
subprogram_general int 0 get_pade_params 		0, int 0 pade_s out, int 0 pade_r out;
subprogram_general int 0 set_sos_params			0, int 0 max_os in,  double 0 max_tau in,  double 0 sos_tol in;
subprogram_general int 0 get_sos_params			0, int 0 max_os out, double 0 max_tau out, double 0 sos_tol out;
subprogram_general int 0 set_fourier_tol		0, double 0 fourier_tol in;
subprogram_general double 0 get_fourier_tol		1;
subprogram_general int 0 set_lambda			0, double 0 lambda in;
subprogram_general double 0 get_lambda			1;
subprogram_general int 0 set_planet_r			0, double 0 planet_r in;
subprogram_general double 0 get_planet_r		1;
subprogram_general int 0 set_levels_z			0, double 1 "d->n_layers + 1" levels_z in;
subprogram_general int 0 get_levels_z			0, double 1 "d->n_layers + 1" levels_z out;
subprogram_general int 0 set_out_levels			0, int 1 "d->n_ulevels" out_levels in;
subprogram_general int 0 get_out_levels			0, int 1 "d->n_ulevels" out_levels out;
subprogram_general int 0 set_out_taus			0, double 1 "d->n_ulevels" out_taus in;
subprogram_general int 0 get_out_taus			0, double 1 "d->n_ulevels" out_taus out;
subprogram_general int 0 set_out_thetas			0, double 1 "d->n_umus" out_thetas in;
subprogram_general int 0 get_out_thetas			0, double 1 "d->n_umus" out_thetas out;
subprogram_general int 0 set_F_iso_top			0, double 0 F_iso_top in;
subprogram_general double 0 get_F_iso_top		1;
subprogram_general int 0 set_F_iso_top_l_1		0, int 0 i_deriv in, double 0 F_iso_top_l in;
subprogram_general int 0 set_F_iso_top_l_n		0, double 1 "d->n_derivs" F_iso_top_l in;
subprogram_general double 0 get_F_iso_top_l		1, int 0 i_deriv in;
subprogram_general int 0 set_F_iso_bot			0, double 0 F_iso_bot in;
subprogram_general double 0 get_F_iso_bot		1;
subprogram_general int 0 set_F_iso_bot_l_1		0, int 0 i_deriv in, double 0 F_iso_bot_l in;
subprogram_general int 0 set_F_iso_bot_l_n		0, double 1 "d->n_derivs" F_iso_bot_l in;
subprogram_general double 0 get_F_iso_bot_l		1, int 0 i_deriv in;
subprogram_general int 0 set_F_0			0, double 0 F_0 in;
subprogram_general double 0 get_F_0			1;
subprogram_general int 0 set_theta_0			0, double 0 theta_0 in;
subprogram_general double 0 get_theta_0			1;
subprogram_general int 0 set_phi_0			0, double 0 phi_0 in;
subprogram_general double 0 get_phi_0			1;
subprogram_general int 0 set_levels_b			0, double 1 "d->n_ulevels" levels_b in;
subprogram_general int 0 get_levels_b			0, double 1 "d->n_ulevels" levels_b out;
subprogram_general int 0 set_levels_b_l_1		0, int 0 i_deriv in, double 1 "d->n_derivs" levels_b_l in;
subprogram_general int 0 set_levels_b_l_n		0, double 2 "d->n_layers + 1" "d->n_derivs" levels_b_l in;
subprogram_general int 0 get_levels_b_l			0, int 0 i_deriv in, double 1 "d->n_layers + 1" levels_b_l out;
subprogram_general int 0 set_surface_b			0, double 0 surface_b in;
subprogram_general double 0 get_surface_b		1;
subprogram_general int 0 set_surface_b_l_1		0, int 0 i_deriv in, double 0 surface_b_l in;
subprogram_general int 0 set_surface_b_l_n		0, double 1 "d->n_derivs" surface_b_l in;
subprogram_general double 0 get_surface_b_l		1, int 0 i_deriv in;
subprogram_general int 0 set_g_1			0, int 0 i_layer in, double 0 g in;
subprogram_general int 0 set_g_n			0, double 1 "d->n_layers" g in;
subprogram_general double 0 get_g			1, int 0 i_layer in;
subprogram_general int 0 set_g_l_11			0, int 0 i_layer in, int 0 i_deriv in, double 0 g_l in;
subprogram_general int 0 set_g_l_n1			0, int 0 i_deriv in, double 1 "d->n_layers" g_l in;
subprogram_general int 0 set_g_l_1n			0, int 0 i_layer in, double 1 "d->n_derivs" g_l in;
subprogram_general int 0 set_g_l_nn			0, double 2 "d->n_layers" "d->n_derivs" g_l in;
subprogram_general double 0 get_g_l			1, int 0 i_layer in, int 0 i_deriv in;
subprogram_general int 0 set_coef_1			0, int 0 i_layer in, int 0 n_coef_layer in, double 2 "d->n_elem" "n_coef_layer" coef in;
subprogram_general int 0 set_coef_n			0, int 1 "d->n_layers" n_coef_layer in, double 3 "d->n_layers" "d->n_elem" "d->n_coef" coef in;
subprogram_general int 0 get_n_coef			1, int 0 i_layer in;
subprogram_general double 0 get_coef			1, int 0 i_layer in, int 0 i_elem in, int 0 i_coef in;
subprogram_general int 0 set_coef_l_11			0, int 0 i_layer in, int 0 i_deriv in, double 2 "d->n_elem" "d->n_coef_layer[i_layer]" coef_l in;
subprogram_general int 0 set_coef_l_n1			0, int 0 i_deriv in, double 3 "d->n_layers" "d->n_elem" "d->n_coef" coef_l in;
subprogram_general int 0 set_coef_l_1n			0, int 0 i_layer in, double 3 "d->n_derivs" "d->n_elem" "d->n_coef_layer[i_layer]" coef_l in;
subprogram_general int 0 set_coef_l_nn			0, double 4 "d->n_layers" "d->n_derivs" "d->n_elem" "d->n_coef" coef_l in;
subprogram_general double 0 get_coef_l 			1, int 0 i_layer in, int 0 i_deriv in, int 0 i_elem in, int 0 i_coef in;
subprogram_general int 0 set_omega_1			0, int 0 i_layer in, double 0 omega in;
subprogram_general int 0 set_omega_n			0, double 1 "d->n_layers" omega in;
subprogram_general double 0 get_omega			1, int 0 i_layer in;
subprogram_general int 0 set_omega_l_11			0, int 0 i_layer in, int 0 i_deriv in, double 0 omega_l in;
subprogram_general int 0 set_omega_l_n1			0, int 0 i_deriv in, double 1 "d->n_layers" omega_l in;
subprogram_general int 0 set_omega_l_1n			0, int 0 i_layer in, double 1 "d->n_derivs" omega_l in;
subprogram_general int 0 set_omega_l_nn			0, double 2 "d->n_layers" "d->n_derivs" omega_l in;
subprogram_general double 0 get_omega_l			1, int 0 i_layer in, int 0 i_deriv in;
subprogram_general int 0 set_ltau_1			0, int 0 i_layer in, double 0 ltau in;
subprogram_general int 0 set_ltau_n			0, double 1 "d->n_layers" ltau in;
subprogram_general double 0 get_ltau			1, int 0 i_layer in;
subprogram_general int 0 set_ltau_l_11			0, int 0 i_layer in, int 0 i_deriv in, double 0 ltau_l in;
subprogram_general int 0 set_ltau_l_n1			0, int 0 i_deriv in, double 1 "d->n_layers" ltau_l in;
subprogram_general int 0 set_ltau_l_1n			0, int 0 i_layer in, double 1 "d->n_derivs" ltau_l in;
subprogram_general int 0 set_ltau_l_nn			0, double 2 "d->n_layers" "d->n_derivs" ltau_l in;
subprogram_general double 0 get_ltau_l			1, int 0 i_layer in, int 0 i_deriv in;
subprogram_general int 0 set_kernel_ampfac		0, int 0 i_kernel in, double 0 ampfac in;
subprogram_general double 0 get_kernel_ampfac		1, int 0 i_kernel in;
subprogram_general int 0 set_kernel_params_1		0, int 0 i_kernel in, int 0 i_param in, double 0 param in;
subprogram_general int 0 set_kernel_params_n		0, int 0 i_kernel in, double 1 "kernel_n_params((enum xrtm_kernel_type) d->kernels[i_kernel])" params in;
subprogram_general double 0 get_kernel_params		1, int 0 i_kernel in, int 0 i_param in;
subprogram_general int 0 set_kernel_ampfac_l_1		0, int 0 i_kernel in, int 0 i_deriv in, double 0 ampfac_l in;
subprogram_general int 0 set_kernel_ampfac_l_n		0, int 0 i_kernel in, double 1 "d->n_derivs" ampfac_l in;
subprogram_general double 0 get_kernel_ampfac_l		1, int 0 i_kernel in, int 0 i_deriv in;
subprogram_general int 0 set_kernel_params_l_11 	0, int 0 i_kernel in, int 0 i_deriv in, int 0 i_param in, double 0 param_l in;
subprogram_general int 0 set_kernel_params_l_1n		0, int 0 i_kernel in, int 0 i_deriv in, double 1 "kernel_n_params((enum xrtm_kernel_type) d->kernels[i_kernel])" params_l in;
subprogram_general int 0 set_kernel_params_l_n1		0, int 0 i_kernel in, int 0 i_param in, double 1 "d->n_derivs" params_l in;
subprogram_general int 0 set_kernel_params_l_nn		0, int 0 i_kernel in, double 2 "d->n_derivs"     "kernel_n_params((enum xrtm_kernel_type) d->kernels[i_kernel])" params_l in;
subprogram_general double 0 get_kernel_params_l		1, int 0 i_kernel in, int 0 i_deriv in, int 0 i_param in;
subprogram_general int 0 update_varied_layers		0;

subprogram_general int 0 qx			        0, double 1 "d->n_quad" qx out;
subprogram_general int 0 qw			        0, double 1 "d->n_quad" qw out;
subprogram_general int 0 kernel_qx			0, double 1 "d->n_kernel_quad" kernel_qx out;
subprogram_general int 0 kernel_qw			0, double 1 "d->n_kernel_quad" kernel_qw out;
subprogram_general int 0 solution			0, enum solver_mask 0 solver in enum_mask xrtm_solver_name_to_mask, int 0 solutions in, int 0 n_out_phis in, double 2 "d->n_umus" "n_out_phis" out_phis in, double 4 "d->n_ulevels" "d->n_umus == 0 ? d->n_quad : d->n_umus" "n_out_phis" "d->n_stokes" I_p out, double 4 "d->n_ulevels" "d->n_umus == 0 ? d->n_quad : d->n_umus" "n_out_phis" "d->n_stokes" I_m out, double 5 "d->n_ulevels" "d->n_derivs" "d->n_umus == 0 ? d->n_quad : d->n_umus" "n_out_phis" "d->n_stokes" K_p out, double 5 "d->n_ulevels" "d->n_derivs" "d->n_umus == 0 ? d->n_quad : d->n_umus" "n_out_phis" "d->n_stokes" K_m out, double 1 "d->n_ulevels" mean_p out, double 1 "d->n_ulevels" mean_m out, double 2 "d->n_ulevels" "d->n_derivs" mean_p_l out, double 2 "d->n_ulevels" "d->n_derivs" mean_m_l out, double 1 "d->n_ulevels" flux_p out, double 1 "d->n_ulevels" flux_m out, double 2 "d->n_ulevels" "d->n_derivs" flux_p_l out, double 2 "d->n_ulevels" "d->n_derivs" flux_m_l out, double 1 "d->n_ulevels" flux_div out, double 2 "d->n_ulevels" "d->n_derivs" flux_div_l out;
subprogram_general int 0 radiance			0, enum solver_mask 0 solver in enum_mask xrtm_solver_name_to_mask, int 0 n_out_phis in, double 2 "d->n_umus" "n_out_phis" out_phis in, double 4 "d->n_ulevels" "d->n_umus == 0 ? d->n_quad : d->n_umus" "n_out_phis" "d->n_stokes" I_p out, double 4 "d->n_ulevels" "d->n_umus == 0 ? d->n_quad : d->n_umus" "n_out_phis" "d->n_stokes" I_m out, double 5 "d->n_ulevels" "d->n_derivs" "d->n_umus == 0 ? d->n_quad : d->n_umus" "n_out_phis" "d->n_stokes" K_p out, double 5 "d->n_ulevels" "d->n_derivs" "d->n_umus == 0 ? d->n_quad : d->n_umus" "n_out_phis" "d->n_stokes" K_m out;
subprogram_general int 0 mean_radiance			0, enum solver_mask 0 solver in enum_mask xrtm_solver_name_to_mask, double 1 "d->n_ulevels" mean_p out, double 1 "d->n_ulevels" mean_m out, double 2 "d->n_ulevels" "d->n_derivs" mean_p_l out, double 2 "d->n_ulevels" "d->n_derivs" mean_m_l out;
subprogram_general int 0 flux				0, enum solver_mask 0 solver in enum_mask xrtm_solver_name_to_mask, double 1 "d->n_ulevels" flux_p out, double 1 "d->n_ulevels" flux_m out, double 2 "d->n_ulevels" "d->n_derivs" flux_p_l out, double 2 "d->n_ulevels" "d->n_derivs" flux_m_l out;
subprogram_general int 0 flux_divergence		0, enum solver_mask 0 solver in enum_mask xrtm_solver_name_to_mask, double 1 "d->n_ulevels" flux_div out, double 2 "d->n_ulevels" "d->n_derivs" flux_div_l out;
