/*******************************************************************************
 * This file was generated by bindx version 0.01.  Edit at your own risk.
 ******************************************************************************/

#include <gutil.h>

#include <export.h>

#include <xrtm_interface.h>

#define ARRLEN(arr) (sizeof(arr)/sizeof(arr[0]))


int  xrtm_int_startup(void);
void xrtm_int_exit_handler(void);

void IDL_CDECL xrtm_create_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_destroy_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_options_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_solvers_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_max_coef_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_n_quad_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_n_stokes_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_n_derivs_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_n_layers_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_n_kernels_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_n_kernel_quad_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_kernel_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_n_out_levels_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_n_out_thetas_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_doub_d_tau_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_doub_d_tau_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_pade_params_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_pade_params_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_sos_params_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_sos_params_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_fourier_tol_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_fourier_tol_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_lambda_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_lambda_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_planet_r_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_planet_r_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_levels_z_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_levels_z_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_out_levels_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_out_levels_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_out_taus_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_out_taus_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_out_thetas_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_out_thetas_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_F_iso_top_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_F_iso_top_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_F_iso_top_l_1_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_F_iso_top_l_n_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_F_iso_top_l_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_F_iso_bot_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_F_iso_bot_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_F_iso_bot_l_1_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_F_iso_bot_l_n_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_F_iso_bot_l_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_F_0_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_F_0_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_theta_0_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_theta_0_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_phi_0_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_phi_0_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_levels_b_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_levels_b_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_levels_b_l_1_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_levels_b_l_n_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_levels_b_l_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_surface_b_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_surface_b_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_surface_b_l_1_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_surface_b_l_n_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_surface_b_l_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_g_1_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_g_n_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_g_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_g_l_11_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_g_l_n1_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_g_l_1n_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_g_l_nn_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_g_l_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_coef_1_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_coef_n_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_n_coef_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_coef_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_coef_l_11_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_coef_l_n1_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_coef_l_1n_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_coef_l_nn_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_coef_l_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_omega_1_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_omega_n_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_omega_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_omega_l_11_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_omega_l_n1_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_omega_l_1n_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_omega_l_nn_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_omega_l_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_ltau_1_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_ltau_n_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_ltau_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_ltau_l_11_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_ltau_l_n1_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_ltau_l_1n_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_ltau_l_nn_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_ltau_l_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_kernel_ampfac_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_kernel_ampfac_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_kernel_params_1_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_kernel_params_n_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_kernel_params_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_kernel_ampfac_l_1_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_kernel_ampfac_l_n_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_kernel_ampfac_l_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_kernel_params_l_11_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_kernel_params_l_1n_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_kernel_params_l_n1_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_set_kernel_params_l_nn_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_get_kernel_params_l_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_update_varied_layers_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_qx_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_qw_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_kernel_qx_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_kernel_qw_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_solution_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_radiance_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_mean_radiance_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_flux_dlm(int argc, IDL_VPTR argv[], char *argk);
void IDL_CDECL xrtm_flux_divergence_dlm(int argc, IDL_VPTR argv[], char *argk);


#ifdef __IDLPRE53__
     static IDL_SYSFUN_DEF xrtm_int_procedures[] = {
          {{(IDL_FUN_RET) xrtm_create_dlm}, "XRTM_CREATE", 13, 13, 0},
          {{(IDL_FUN_RET) xrtm_destroy_dlm}, "XRTM_DESTROY", 1, 1, 0},
          {{(IDL_FUN_RET) xrtm_get_options_dlm}, "XRTM_GET_OPTIONS", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_solvers_dlm}, "XRTM_GET_SOLVERS", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_max_coef_dlm}, "XRTM_GET_MAX_COEF", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_n_quad_dlm}, "XRTM_GET_N_QUAD", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_n_stokes_dlm}, "XRTM_GET_N_STOKES", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_n_derivs_dlm}, "XRTM_GET_N_DERIVS", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_n_layers_dlm}, "XRTM_GET_N_LAYERS", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_n_kernels_dlm}, "XRTM_GET_N_KERNELS", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_n_kernel_quad_dlm}, "XRTM_GET_N_KERNEL_QUAD", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_kernel_dlm}, "XRTM_GET_KERNEL", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_get_n_out_levels_dlm}, "XRTM_GET_N_OUT_LEVELS", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_n_out_thetas_dlm}, "XRTM_GET_N_OUT_THETAS", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_set_doub_d_tau_dlm}, "XRTM_SET_DOUB_D_TAU", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_doub_d_tau_dlm}, "XRTM_GET_DOUB_D_TAU", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_set_pade_params_dlm}, "XRTM_SET_PADE_PARAMS", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_get_pade_params_dlm}, "XRTM_GET_PADE_PARAMS", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_set_sos_params_dlm}, "XRTM_SET_SOS_PARAMS", 4, 4, 0},
          {{(IDL_FUN_RET) xrtm_get_sos_params_dlm}, "XRTM_GET_SOS_PARAMS", 4, 4, 0},
          {{(IDL_FUN_RET) xrtm_set_fourier_tol_dlm}, "XRTM_SET_FOURIER_TOL", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_fourier_tol_dlm}, "XRTM_GET_FOURIER_TOL", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_set_lambda_dlm}, "XRTM_SET_LAMBDA", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_lambda_dlm}, "XRTM_GET_LAMBDA", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_set_planet_r_dlm}, "XRTM_SET_PLANET_R", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_planet_r_dlm}, "XRTM_GET_PLANET_R", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_set_levels_z_dlm}, "XRTM_SET_LEVELS_Z", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_levels_z_dlm}, "XRTM_GET_LEVELS_Z", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_set_out_levels_dlm}, "XRTM_SET_OUT_LEVELS", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_out_levels_dlm}, "XRTM_GET_OUT_LEVELS", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_set_out_taus_dlm}, "XRTM_SET_OUT_TAUS", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_out_taus_dlm}, "XRTM_GET_OUT_TAUS", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_set_out_thetas_dlm}, "XRTM_SET_OUT_THETAS", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_out_thetas_dlm}, "XRTM_GET_OUT_THETAS", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_set_F_iso_top_dlm}, "XRTM_SET_F_ISO_TOP", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_F_iso_top_dlm}, "XRTM_GET_F_ISO_TOP", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_set_F_iso_top_l_1_dlm}, "XRTM_SET_F_ISO_TOP_L_1", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_set_F_iso_top_l_n_dlm}, "XRTM_SET_F_ISO_TOP_L_N", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_F_iso_top_l_dlm}, "XRTM_GET_F_ISO_TOP_L", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_set_F_iso_bot_dlm}, "XRTM_SET_F_ISO_BOT", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_F_iso_bot_dlm}, "XRTM_GET_F_ISO_BOT", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_set_F_iso_bot_l_1_dlm}, "XRTM_SET_F_ISO_BOT_L_1", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_set_F_iso_bot_l_n_dlm}, "XRTM_SET_F_ISO_BOT_L_N", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_F_iso_bot_l_dlm}, "XRTM_GET_F_ISO_BOT_L", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_set_F_0_dlm}, "XRTM_SET_F_0", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_F_0_dlm}, "XRTM_GET_F_0", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_set_theta_0_dlm}, "XRTM_SET_THETA_0", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_theta_0_dlm}, "XRTM_GET_THETA_0", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_set_phi_0_dlm}, "XRTM_SET_PHI_0", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_phi_0_dlm}, "XRTM_GET_PHI_0", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_set_levels_b_dlm}, "XRTM_SET_LEVELS_B", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_levels_b_dlm}, "XRTM_GET_LEVELS_B", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_set_levels_b_l_1_dlm}, "XRTM_SET_LEVELS_B_L_1", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_set_levels_b_l_n_dlm}, "XRTM_SET_LEVELS_B_L_N", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_levels_b_l_dlm}, "XRTM_GET_LEVELS_B_L", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_set_surface_b_dlm}, "XRTM_SET_SURFACE_B", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_surface_b_dlm}, "XRTM_GET_SURFACE_B", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_set_surface_b_l_1_dlm}, "XRTM_SET_SURFACE_B_L_1", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_set_surface_b_l_n_dlm}, "XRTM_SET_SURFACE_B_L_N", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_surface_b_l_dlm}, "XRTM_GET_SURFACE_B_L", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_set_g_1_dlm}, "XRTM_SET_G_1", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_set_g_n_dlm}, "XRTM_SET_G_N", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_g_dlm}, "XRTM_GET_G", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_set_g_l_11_dlm}, "XRTM_SET_G_L_11", 4, 4, 0},
          {{(IDL_FUN_RET) xrtm_set_g_l_n1_dlm}, "XRTM_SET_G_L_N1", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_set_g_l_1n_dlm}, "XRTM_SET_G_L_1N", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_set_g_l_nn_dlm}, "XRTM_SET_G_L_NN", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_g_l_dlm}, "XRTM_GET_G_L", 4, 4, 0},
          {{(IDL_FUN_RET) xrtm_set_coef_1_dlm}, "XRTM_SET_COEF_1", 4, 4, 0},
          {{(IDL_FUN_RET) xrtm_set_coef_n_dlm}, "XRTM_SET_COEF_N", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_get_n_coef_dlm}, "XRTM_GET_N_COEF", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_get_coef_dlm}, "XRTM_GET_COEF", 5, 5, 0},
          {{(IDL_FUN_RET) xrtm_set_coef_l_11_dlm}, "XRTM_SET_COEF_L_11", 4, 4, 0},
          {{(IDL_FUN_RET) xrtm_set_coef_l_n1_dlm}, "XRTM_SET_COEF_L_N1", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_set_coef_l_1n_dlm}, "XRTM_SET_COEF_L_1N", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_set_coef_l_nn_dlm}, "XRTM_SET_COEF_L_NN", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_coef_l_dlm}, "XRTM_GET_COEF_L", 6, 6, 0},
          {{(IDL_FUN_RET) xrtm_set_omega_1_dlm}, "XRTM_SET_OMEGA_1", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_set_omega_n_dlm}, "XRTM_SET_OMEGA_N", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_omega_dlm}, "XRTM_GET_OMEGA", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_set_omega_l_11_dlm}, "XRTM_SET_OMEGA_L_11", 4, 4, 0},
          {{(IDL_FUN_RET) xrtm_set_omega_l_n1_dlm}, "XRTM_SET_OMEGA_L_N1", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_set_omega_l_1n_dlm}, "XRTM_SET_OMEGA_L_1N", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_set_omega_l_nn_dlm}, "XRTM_SET_OMEGA_L_NN", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_omega_l_dlm}, "XRTM_GET_OMEGA_L", 4, 4, 0},
          {{(IDL_FUN_RET) xrtm_set_ltau_1_dlm}, "XRTM_SET_LTAU_1", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_set_ltau_n_dlm}, "XRTM_SET_LTAU_N", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_ltau_dlm}, "XRTM_GET_LTAU", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_set_ltau_l_11_dlm}, "XRTM_SET_LTAU_L_11", 4, 4, 0},
          {{(IDL_FUN_RET) xrtm_set_ltau_l_n1_dlm}, "XRTM_SET_LTAU_L_N1", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_set_ltau_l_1n_dlm}, "XRTM_SET_LTAU_L_1N", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_set_ltau_l_nn_dlm}, "XRTM_SET_LTAU_L_NN", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_get_ltau_l_dlm}, "XRTM_GET_LTAU_L", 4, 4, 0},
          {{(IDL_FUN_RET) xrtm_set_kernel_ampfac_dlm}, "XRTM_SET_KERNEL_AMPFAC", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_get_kernel_ampfac_dlm}, "XRTM_GET_KERNEL_AMPFAC", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_set_kernel_params_1_dlm}, "XRTM_SET_KERNEL_PARAMS_1", 4, 4, 0},
          {{(IDL_FUN_RET) xrtm_set_kernel_params_n_dlm}, "XRTM_SET_KERNEL_PARAMS_N", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_get_kernel_params_dlm}, "XRTM_GET_KERNEL_PARAMS", 4, 4, 0},
          {{(IDL_FUN_RET) xrtm_set_kernel_ampfac_l_1_dlm}, "XRTM_SET_KERNEL_AMPFAC_L_1", 4, 4, 0},
          {{(IDL_FUN_RET) xrtm_set_kernel_ampfac_l_n_dlm}, "XRTM_SET_KERNEL_AMPFAC_L_N", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_get_kernel_ampfac_l_dlm}, "XRTM_GET_KERNEL_AMPFAC_L", 4, 4, 0},
          {{(IDL_FUN_RET) xrtm_set_kernel_params_l_11_dlm}, "XRTM_SET_KERNEL_PARAMS_L_11", 5, 5, 0},
          {{(IDL_FUN_RET) xrtm_set_kernel_params_l_1n_dlm}, "XRTM_SET_KERNEL_PARAMS_L_1N", 4, 4, 0},
          {{(IDL_FUN_RET) xrtm_set_kernel_params_l_n1_dlm}, "XRTM_SET_KERNEL_PARAMS_L_N1", 4, 4, 0},
          {{(IDL_FUN_RET) xrtm_set_kernel_params_l_nn_dlm}, "XRTM_SET_KERNEL_PARAMS_L_NN", 3, 3, 0},
          {{(IDL_FUN_RET) xrtm_get_kernel_params_l_dlm}, "XRTM_GET_KERNEL_PARAMS_L", 5, 5, 0},
          {{(IDL_FUN_RET) xrtm_update_varied_layers_dlm}, "XRTM_UPDATE_VARIED_LAYERS", 1, 1, 0},
          {{(IDL_FUN_RET) xrtm_qx_dlm}, "XRTM_QX", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_qw_dlm}, "XRTM_QW", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_kernel_qx_dlm}, "XRTM_KERNEL_QX", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_kernel_qw_dlm}, "XRTM_KERNEL_QW", 2, 2, 0},
          {{(IDL_FUN_RET) xrtm_solution_dlm}, "XRTM_SOLUTION", 19, 19, 0},
          {{(IDL_FUN_RET) xrtm_radiance_dlm}, "XRTM_RADIANCE", 8, 8, 0},
          {{(IDL_FUN_RET) xrtm_mean_radiance_dlm}, "XRTM_MEAN_RADIANCE", 6, 6, 0},
          {{(IDL_FUN_RET) xrtm_flux_dlm}, "XRTM_FLUX", 6, 6, 0},
          {{(IDL_FUN_RET) xrtm_flux_divergence_dlm}, "XRTM_FLUX_DIVERGENCE", 4, 4, 0}
     };
#else
     static IDL_SYSFUN_DEF2 xrtm_int_procedures[] = {
          {{(IDL_FUN_RET) xrtm_create_dlm}, "XRTM_CREATE", 13, 13, 0, 0},
          {{(IDL_FUN_RET) xrtm_destroy_dlm}, "XRTM_DESTROY", 1, 1, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_options_dlm}, "XRTM_GET_OPTIONS", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_solvers_dlm}, "XRTM_GET_SOLVERS", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_max_coef_dlm}, "XRTM_GET_MAX_COEF", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_n_quad_dlm}, "XRTM_GET_N_QUAD", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_n_stokes_dlm}, "XRTM_GET_N_STOKES", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_n_derivs_dlm}, "XRTM_GET_N_DERIVS", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_n_layers_dlm}, "XRTM_GET_N_LAYERS", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_n_kernels_dlm}, "XRTM_GET_N_KERNELS", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_n_kernel_quad_dlm}, "XRTM_GET_N_KERNEL_QUAD", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_kernel_dlm}, "XRTM_GET_KERNEL", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_n_out_levels_dlm}, "XRTM_GET_N_OUT_LEVELS", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_n_out_thetas_dlm}, "XRTM_GET_N_OUT_THETAS", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_doub_d_tau_dlm}, "XRTM_SET_DOUB_D_TAU", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_doub_d_tau_dlm}, "XRTM_GET_DOUB_D_TAU", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_pade_params_dlm}, "XRTM_SET_PADE_PARAMS", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_pade_params_dlm}, "XRTM_GET_PADE_PARAMS", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_sos_params_dlm}, "XRTM_SET_SOS_PARAMS", 4, 4, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_sos_params_dlm}, "XRTM_GET_SOS_PARAMS", 4, 4, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_fourier_tol_dlm}, "XRTM_SET_FOURIER_TOL", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_fourier_tol_dlm}, "XRTM_GET_FOURIER_TOL", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_lambda_dlm}, "XRTM_SET_LAMBDA", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_lambda_dlm}, "XRTM_GET_LAMBDA", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_planet_r_dlm}, "XRTM_SET_PLANET_R", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_planet_r_dlm}, "XRTM_GET_PLANET_R", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_levels_z_dlm}, "XRTM_SET_LEVELS_Z", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_levels_z_dlm}, "XRTM_GET_LEVELS_Z", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_out_levels_dlm}, "XRTM_SET_OUT_LEVELS", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_out_levels_dlm}, "XRTM_GET_OUT_LEVELS", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_out_taus_dlm}, "XRTM_SET_OUT_TAUS", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_out_taus_dlm}, "XRTM_GET_OUT_TAUS", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_out_thetas_dlm}, "XRTM_SET_OUT_THETAS", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_out_thetas_dlm}, "XRTM_GET_OUT_THETAS", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_F_iso_top_dlm}, "XRTM_SET_F_ISO_TOP", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_F_iso_top_dlm}, "XRTM_GET_F_ISO_TOP", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_F_iso_top_l_1_dlm}, "XRTM_SET_F_ISO_TOP_L_1", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_F_iso_top_l_n_dlm}, "XRTM_SET_F_ISO_TOP_L_N", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_F_iso_top_l_dlm}, "XRTM_GET_F_ISO_TOP_L", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_F_iso_bot_dlm}, "XRTM_SET_F_ISO_BOT", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_F_iso_bot_dlm}, "XRTM_GET_F_ISO_BOT", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_F_iso_bot_l_1_dlm}, "XRTM_SET_F_ISO_BOT_L_1", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_F_iso_bot_l_n_dlm}, "XRTM_SET_F_ISO_BOT_L_N", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_F_iso_bot_l_dlm}, "XRTM_GET_F_ISO_BOT_L", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_F_0_dlm}, "XRTM_SET_F_0", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_F_0_dlm}, "XRTM_GET_F_0", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_theta_0_dlm}, "XRTM_SET_THETA_0", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_theta_0_dlm}, "XRTM_GET_THETA_0", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_phi_0_dlm}, "XRTM_SET_PHI_0", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_phi_0_dlm}, "XRTM_GET_PHI_0", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_levels_b_dlm}, "XRTM_SET_LEVELS_B", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_levels_b_dlm}, "XRTM_GET_LEVELS_B", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_levels_b_l_1_dlm}, "XRTM_SET_LEVELS_B_L_1", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_levels_b_l_n_dlm}, "XRTM_SET_LEVELS_B_L_N", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_levels_b_l_dlm}, "XRTM_GET_LEVELS_B_L", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_surface_b_dlm}, "XRTM_SET_SURFACE_B", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_surface_b_dlm}, "XRTM_GET_SURFACE_B", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_surface_b_l_1_dlm}, "XRTM_SET_SURFACE_B_L_1", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_surface_b_l_n_dlm}, "XRTM_SET_SURFACE_B_L_N", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_surface_b_l_dlm}, "XRTM_GET_SURFACE_B_L", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_g_1_dlm}, "XRTM_SET_G_1", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_g_n_dlm}, "XRTM_SET_G_N", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_g_dlm}, "XRTM_GET_G", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_g_l_11_dlm}, "XRTM_SET_G_L_11", 4, 4, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_g_l_n1_dlm}, "XRTM_SET_G_L_N1", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_g_l_1n_dlm}, "XRTM_SET_G_L_1N", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_g_l_nn_dlm}, "XRTM_SET_G_L_NN", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_g_l_dlm}, "XRTM_GET_G_L", 4, 4, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_coef_1_dlm}, "XRTM_SET_COEF_1", 4, 4, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_coef_n_dlm}, "XRTM_SET_COEF_N", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_n_coef_dlm}, "XRTM_GET_N_COEF", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_coef_dlm}, "XRTM_GET_COEF", 5, 5, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_coef_l_11_dlm}, "XRTM_SET_COEF_L_11", 4, 4, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_coef_l_n1_dlm}, "XRTM_SET_COEF_L_N1", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_coef_l_1n_dlm}, "XRTM_SET_COEF_L_1N", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_coef_l_nn_dlm}, "XRTM_SET_COEF_L_NN", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_coef_l_dlm}, "XRTM_GET_COEF_L", 6, 6, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_omega_1_dlm}, "XRTM_SET_OMEGA_1", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_omega_n_dlm}, "XRTM_SET_OMEGA_N", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_omega_dlm}, "XRTM_GET_OMEGA", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_omega_l_11_dlm}, "XRTM_SET_OMEGA_L_11", 4, 4, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_omega_l_n1_dlm}, "XRTM_SET_OMEGA_L_N1", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_omega_l_1n_dlm}, "XRTM_SET_OMEGA_L_1N", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_omega_l_nn_dlm}, "XRTM_SET_OMEGA_L_NN", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_omega_l_dlm}, "XRTM_GET_OMEGA_L", 4, 4, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_ltau_1_dlm}, "XRTM_SET_LTAU_1", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_ltau_n_dlm}, "XRTM_SET_LTAU_N", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_ltau_dlm}, "XRTM_GET_LTAU", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_ltau_l_11_dlm}, "XRTM_SET_LTAU_L_11", 4, 4, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_ltau_l_n1_dlm}, "XRTM_SET_LTAU_L_N1", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_ltau_l_1n_dlm}, "XRTM_SET_LTAU_L_1N", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_ltau_l_nn_dlm}, "XRTM_SET_LTAU_L_NN", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_ltau_l_dlm}, "XRTM_GET_LTAU_L", 4, 4, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_kernel_ampfac_dlm}, "XRTM_SET_KERNEL_AMPFAC", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_kernel_ampfac_dlm}, "XRTM_GET_KERNEL_AMPFAC", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_kernel_params_1_dlm}, "XRTM_SET_KERNEL_PARAMS_1", 4, 4, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_kernel_params_n_dlm}, "XRTM_SET_KERNEL_PARAMS_N", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_kernel_params_dlm}, "XRTM_GET_KERNEL_PARAMS", 4, 4, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_kernel_ampfac_l_1_dlm}, "XRTM_SET_KERNEL_AMPFAC_L_1", 4, 4, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_kernel_ampfac_l_n_dlm}, "XRTM_SET_KERNEL_AMPFAC_L_N", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_kernel_ampfac_l_dlm}, "XRTM_GET_KERNEL_AMPFAC_L", 4, 4, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_kernel_params_l_11_dlm}, "XRTM_SET_KERNEL_PARAMS_L_11", 5, 5, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_kernel_params_l_1n_dlm}, "XRTM_SET_KERNEL_PARAMS_L_1N", 4, 4, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_kernel_params_l_n1_dlm}, "XRTM_SET_KERNEL_PARAMS_L_N1", 4, 4, 0, 0},
          {{(IDL_FUN_RET) xrtm_set_kernel_params_l_nn_dlm}, "XRTM_SET_KERNEL_PARAMS_L_NN", 3, 3, 0, 0},
          {{(IDL_FUN_RET) xrtm_get_kernel_params_l_dlm}, "XRTM_GET_KERNEL_PARAMS_L", 5, 5, 0, 0},
          {{(IDL_FUN_RET) xrtm_update_varied_layers_dlm}, "XRTM_UPDATE_VARIED_LAYERS", 1, 1, 0, 0},
          {{(IDL_FUN_RET) xrtm_qx_dlm}, "XRTM_QX", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_qw_dlm}, "XRTM_QW", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_kernel_qx_dlm}, "XRTM_KERNEL_QX", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_kernel_qw_dlm}, "XRTM_KERNEL_QW", 2, 2, 0, 0},
          {{(IDL_FUN_RET) xrtm_solution_dlm}, "XRTM_SOLUTION", 19, 19, 0, 0},
          {{(IDL_FUN_RET) xrtm_radiance_dlm}, "XRTM_RADIANCE", 8, 8, 0, 0},
          {{(IDL_FUN_RET) xrtm_mean_radiance_dlm}, "XRTM_MEAN_RADIANCE", 6, 6, 0, 0},
          {{(IDL_FUN_RET) xrtm_flux_dlm}, "XRTM_FLUX", 6, 6, 0, 0},
          {{(IDL_FUN_RET) xrtm_flux_divergence_dlm}, "XRTM_FLUX_DIVERGENCE", 4, 4, 0, 0}
     };
#endif


int IDL_Load(void)
{
#ifdef __IDLPRE53__
     if (! IDL_AddSystemRoutine(xrtm_int_procedures, FALSE,
                                ARRLEN(xrtm_int_procedures))) {
          return IDL_FALSE;
     }
#else
     if (! IDL_SysRtnAdd       (xrtm_int_procedures, FALSE,
                                ARRLEN(xrtm_int_procedures))) {
          return IDL_FALSE;
     }
#endif
     IDL_ExitRegister(xrtm_int_exit_handler);
     return(IDL_TRUE);
}


void xrtm_int_exit_handler(void)
{

}


void IDL_CDECL xrtm_create_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     IDL_VPTR ptr;
     IDL_MEMINT dim_idl[16];
     int options;
     int solvers;
     int max_coef;
     int n_quad;
     int n_stokes;
     int n_derivs;
     int n_layers;
     int n_theta_0s;
     int n_kernels;
     int n_kernel_quad;
     enum xrtm_kernel_type *kernels;
     int n_out_levels;
     int n_out_thetas;
     {
     int i;
     options = 0;
     IDL_ENSURE_ARRAY(argv[1]);
     for (i = 0; i < argv[1]->value.arr->n_elts; ++i) {
          if ((r = xrtm_option_name_to_mask(((IDL_STRING *) argv[1]->value.arr->data)[i].s)) < 0)
               IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_option_name_to_mask()");
          options |= r;
     }}
     {
     int i;
     solvers = 0;
     IDL_ENSURE_ARRAY(argv[2]);
     for (i = 0; i < argv[2]->value.arr->n_elts; ++i) {
          if ((r = xrtm_solver_name_to_mask(((IDL_STRING *) argv[2]->value.arr->data)[i].s)) < 0)
               IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_solver_name_to_mask()");
          solvers |= r;
     }}
     IDL_ENSURE_SCALAR(argv[3]);
     if (argv[3]->type != IDL_TYP_LONG && argv[3]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: max_coef must be of type long or int");
     if (argv[3]->type == IDL_TYP_LONG)
          max_coef = argv[3]->value.l;
     else
          max_coef = argv[3]->value.i;
     IDL_ENSURE_SCALAR(argv[4]);
     if (argv[4]->type != IDL_TYP_LONG && argv[4]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: n_quad must be of type long or int");
     if (argv[4]->type == IDL_TYP_LONG)
          n_quad = argv[4]->value.l;
     else
          n_quad = argv[4]->value.i;
     IDL_ENSURE_SCALAR(argv[5]);
     if (argv[5]->type != IDL_TYP_LONG && argv[5]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: n_stokes must be of type long or int");
     if (argv[5]->type == IDL_TYP_LONG)
          n_stokes = argv[5]->value.l;
     else
          n_stokes = argv[5]->value.i;
     IDL_ENSURE_SCALAR(argv[6]);
     if (argv[6]->type != IDL_TYP_LONG && argv[6]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: n_derivs must be of type long or int");
     if (argv[6]->type == IDL_TYP_LONG)
          n_derivs = argv[6]->value.l;
     else
          n_derivs = argv[6]->value.i;
     IDL_ENSURE_SCALAR(argv[7]);
     if (argv[7]->type != IDL_TYP_LONG && argv[7]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: n_layers must be of type long or int");
     if (argv[7]->type == IDL_TYP_LONG)
          n_layers = argv[7]->value.l;
     else
          n_layers = argv[7]->value.i;
     IDL_ENSURE_SCALAR(argv[8]);
     if (argv[8]->type != IDL_TYP_LONG && argv[8]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: n_theta_0s must be of type long or int");
     if (argv[8]->type == IDL_TYP_LONG)
          n_theta_0s = argv[8]->value.l;
     else
          n_theta_0s = argv[8]->value.i;
     IDL_ENSURE_SCALAR(argv[9]);
     if (argv[9]->type != IDL_TYP_LONG && argv[9]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: n_kernel_quad must be of type long or int");
     if (argv[9]->type == IDL_TYP_LONG)
          n_kernel_quad = argv[9]->value.l;
     else
          n_kernel_quad = argv[9]->value.i;
     {
     int i;
     IDL_ENSURE_ARRAY(argv[10]);
     n_kernels = argv[10]->value.arr->n_elts;
     kernels = malloc(n_kernels * sizeof(int));
     for (i = 0; i < argv[10]->value.arr->n_elts; ++i) {
          if ((r = xrtm_kernel_name_to_value(((IDL_STRING *) argv[10]->value.arr->data)[i].s)) < 0)
               IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_kernel_name_to_value()");
          kernels[i] = r;
     }}
     IDL_ENSURE_SCALAR(argv[11]);
     if (argv[11]->type != IDL_TYP_LONG && argv[11]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: n_out_levels must be of type long or int");
     if (argv[11]->type == IDL_TYP_LONG)
          n_out_levels = argv[11]->value.l;
     else
          n_out_levels = argv[11]->value.i;
     IDL_ENSURE_SCALAR(argv[12]);
     if (argv[12]->type != IDL_TYP_LONG && argv[12]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: n_out_thetas must be of type long or int");
     if (argv[12]->type == IDL_TYP_LONG)
          n_out_thetas = argv[12]->value.l;
     else
          n_out_thetas = argv[12]->value.i;
     d = malloc(sizeof(xrtm_data));
     r = xrtm_create(d, options, solvers, max_coef, n_quad, n_stokes, n_derivs, n_layers, n_theta_0s, n_kernels, n_kernel_quad, (enum xrtm_kernel_type *) kernels, n_out_levels, n_out_thetas);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_create()");
     free(kernels);
     dim_idl[0] = sizeof(xrtm_data);
     ptr = IDL_ImportArray(1, (IDL_MEMINT *) dim_idl, IDL_TYP_BYTE, (UCHAR *) d, 0, NULL);
     IDL_VarCopy(ptr, argv[0]);
     return;
}


void IDL_CDECL xrtm_destroy_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     r = xrtm_destroy(d);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_destroy()");
     return;
}


void IDL_CDECL xrtm_get_options_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     IDL_VARIABLE var;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     r = xrtm_get_options(d);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_options()");
     var.type = IDL_TYP_LONG;
     var.flags = 0;
     var.value.l = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_options()");
     IDL_VarCopy((IDL_VPTR) &var, argv[1]);
     return;
}


void IDL_CDECL xrtm_get_solvers_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     IDL_VARIABLE var;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     r = xrtm_get_solvers(d);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_solvers()");
     var.type = IDL_TYP_LONG;
     var.flags = 0;
     var.value.l = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_solvers()");
     IDL_VarCopy((IDL_VPTR) &var, argv[1]);
     return;
}


void IDL_CDECL xrtm_get_max_coef_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     IDL_VARIABLE var;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     r = xrtm_get_max_coef(d);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_max_coef()");
     var.type = IDL_TYP_LONG;
     var.flags = 0;
     var.value.l = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_max_coef()");
     IDL_VarCopy((IDL_VPTR) &var, argv[1]);
     return;
}


void IDL_CDECL xrtm_get_n_quad_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     IDL_VARIABLE var;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     r = xrtm_get_n_quad(d);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_n_quad()");
     var.type = IDL_TYP_LONG;
     var.flags = 0;
     var.value.l = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_n_quad()");
     IDL_VarCopy((IDL_VPTR) &var, argv[1]);
     return;
}


void IDL_CDECL xrtm_get_n_stokes_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     IDL_VARIABLE var;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     r = xrtm_get_n_stokes(d);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_n_stokes()");
     var.type = IDL_TYP_LONG;
     var.flags = 0;
     var.value.l = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_n_stokes()");
     IDL_VarCopy((IDL_VPTR) &var, argv[1]);
     return;
}


void IDL_CDECL xrtm_get_n_derivs_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     IDL_VARIABLE var;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     r = xrtm_get_n_derivs(d);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_n_derivs()");
     var.type = IDL_TYP_LONG;
     var.flags = 0;
     var.value.l = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_n_derivs()");
     IDL_VarCopy((IDL_VPTR) &var, argv[1]);
     return;
}


void IDL_CDECL xrtm_get_n_layers_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     IDL_VARIABLE var;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     r = xrtm_get_n_layers(d);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_n_layers()");
     var.type = IDL_TYP_LONG;
     var.flags = 0;
     var.value.l = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_n_layers()");
     IDL_VarCopy((IDL_VPTR) &var, argv[1]);
     return;
}


void IDL_CDECL xrtm_get_n_kernels_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     IDL_VARIABLE var;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     r = xrtm_get_n_kernels(d);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_n_kernels()");
     var.type = IDL_TYP_LONG;
     var.flags = 0;
     var.value.l = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_n_kernels()");
     IDL_VarCopy((IDL_VPTR) &var, argv[1]);
     return;
}


void IDL_CDECL xrtm_get_n_kernel_quad_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     IDL_VARIABLE var;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     r = xrtm_get_n_kernel_quad(d);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_n_kernel_quad()");
     var.type = IDL_TYP_LONG;
     var.flags = 0;
     var.value.l = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_n_kernel_quad()");
     IDL_VarCopy((IDL_VPTR) &var, argv[1]);
     return;
}


void IDL_CDECL xrtm_get_kernel_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     IDL_VARIABLE var;
     int i_kernel;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_kernel must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_kernel = argv[1]->value.l;
     else
          i_kernel = argv[1]->value.i;
     r = xrtm_get_kernel(d, i_kernel);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_kernel()");
     var.type = IDL_TYP_LONG;
     var.flags = 0;
     var.value.l = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_kernel()");
     IDL_VarCopy((IDL_VPTR) &var, argv[2]);
     return;
}


void IDL_CDECL xrtm_get_n_out_levels_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     IDL_VARIABLE var;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     r = xrtm_get_n_out_levels(d);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_n_out_levels()");
     var.type = IDL_TYP_LONG;
     var.flags = 0;
     var.value.l = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_n_out_levels()");
     IDL_VarCopy((IDL_VPTR) &var, argv[1]);
     return;
}


void IDL_CDECL xrtm_get_n_out_thetas_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     IDL_VARIABLE var;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     r = xrtm_get_n_out_thetas(d);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_n_out_thetas()");
     var.type = IDL_TYP_LONG;
     var.flags = 0;
     var.value.l = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_n_out_thetas()");
     IDL_VarCopy((IDL_VPTR) &var, argv[1]);
     return;
}


void IDL_CDECL xrtm_set_doub_d_tau_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     double d_tau;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_DOUBLE && argv[1]->type != IDL_TYP_FLOAT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: d_tau must be of type double or float");
     if (argv[1]->type == IDL_TYP_DOUBLE)
          d_tau = argv[1]->value.d;
     else
          d_tau = argv[1]->value.f;
     r = xrtm_set_doub_d_tau(d, d_tau);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_doub_d_tau()");
     return;
}


void IDL_CDECL xrtm_get_doub_d_tau_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     double r;
     xrtm_data *d;
     IDL_VARIABLE var;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     r = xrtm_get_doub_d_tau(d);
     if (r == XRTM_DBL_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_doub_d_tau()");
     var.type = IDL_TYP_DOUBLE;
     var.flags = 0;
     var.value.d = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_doub_d_tau()");
     IDL_VarCopy((IDL_VPTR) &var, argv[1]);
     return;
}


void IDL_CDECL xrtm_set_pade_params_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     int pade_s;
     int pade_r;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: pade_s must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          pade_s = argv[1]->value.l;
     else
          pade_s = argv[1]->value.i;
     IDL_ENSURE_SCALAR(argv[2]);
     if (argv[2]->type != IDL_TYP_LONG && argv[2]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: pade_r must be of type long or int");
     if (argv[2]->type == IDL_TYP_LONG)
          pade_r = argv[2]->value.l;
     else
          pade_r = argv[2]->value.i;
     r = xrtm_set_pade_params(d, pade_s, pade_r);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_pade_params()");
     return;
}


void IDL_CDECL xrtm_get_pade_params_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     IDL_VARIABLE var;
     int pade_s;
     int pade_r;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: pade_s must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          pade_s = argv[1]->value.l;
     else
          pade_s = argv[1]->value.i;
     IDL_ENSURE_SCALAR(argv[2]);
     if (argv[2]->type != IDL_TYP_LONG && argv[2]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: pade_r must be of type long or int");
     if (argv[2]->type == IDL_TYP_LONG)
          pade_r = argv[2]->value.l;
     else
          pade_r = argv[2]->value.i;
     r = xrtm_get_pade_params(d, &pade_s, &pade_r);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_pade_params()");
     var.type = IDL_TYP_LONG;
     var.flags = 0;
     var.value.l = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_pade_params()");
     IDL_VarCopy((IDL_VPTR) &var, argv[1]);
     var.type = IDL_TYP_LONG;
     var.flags = 0;
     var.value.l = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_pade_params()");
     IDL_VarCopy((IDL_VPTR) &var, argv[2]);
     return;
}


void IDL_CDECL xrtm_set_sos_params_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     int max_os;
     double max_tau;
     double sos_tol;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: max_os must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          max_os = argv[1]->value.l;
     else
          max_os = argv[1]->value.i;
     IDL_ENSURE_SCALAR(argv[2]);
     if (argv[2]->type != IDL_TYP_DOUBLE && argv[2]->type != IDL_TYP_FLOAT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: max_tau must be of type double or float");
     if (argv[2]->type == IDL_TYP_DOUBLE)
          max_tau = argv[2]->value.d;
     else
          max_tau = argv[2]->value.f;
     IDL_ENSURE_SCALAR(argv[3]);
     if (argv[3]->type != IDL_TYP_DOUBLE && argv[3]->type != IDL_TYP_FLOAT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: sos_tol must be of type double or float");
     if (argv[3]->type == IDL_TYP_DOUBLE)
          sos_tol = argv[3]->value.d;
     else
          sos_tol = argv[3]->value.f;
     r = xrtm_set_sos_params(d, max_os, max_tau, sos_tol);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_sos_params()");
     return;
}


void IDL_CDECL xrtm_get_sos_params_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     IDL_VARIABLE var;
     int max_os;
     double max_tau;
     double sos_tol;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: max_os must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          max_os = argv[1]->value.l;
     else
          max_os = argv[1]->value.i;
     IDL_ENSURE_SCALAR(argv[2]);
     if (argv[2]->type != IDL_TYP_DOUBLE && argv[2]->type != IDL_TYP_FLOAT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: max_tau must be of type double or float");
     if (argv[2]->type == IDL_TYP_DOUBLE)
          max_tau = argv[2]->value.d;
     else
          max_tau = argv[2]->value.f;
     IDL_ENSURE_SCALAR(argv[3]);
     if (argv[3]->type != IDL_TYP_DOUBLE && argv[3]->type != IDL_TYP_FLOAT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: sos_tol must be of type double or float");
     if (argv[3]->type == IDL_TYP_DOUBLE)
          sos_tol = argv[3]->value.d;
     else
          sos_tol = argv[3]->value.f;
     r = xrtm_get_sos_params(d, &max_os, &max_tau, &sos_tol);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_sos_params()");
     var.type = IDL_TYP_LONG;
     var.flags = 0;
     var.value.l = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_sos_params()");
     IDL_VarCopy((IDL_VPTR) &var, argv[1]);
     var.type = IDL_TYP_DOUBLE;
     var.flags = 0;
     var.value.d = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_sos_params()");
     IDL_VarCopy((IDL_VPTR) &var, argv[2]);
     var.type = IDL_TYP_DOUBLE;
     var.flags = 0;
     var.value.d = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_sos_params()");
     IDL_VarCopy((IDL_VPTR) &var, argv[3]);
     return;
}


void IDL_CDECL xrtm_set_fourier_tol_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     double fourier_tol;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_DOUBLE && argv[1]->type != IDL_TYP_FLOAT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: fourier_tol must be of type double or float");
     if (argv[1]->type == IDL_TYP_DOUBLE)
          fourier_tol = argv[1]->value.d;
     else
          fourier_tol = argv[1]->value.f;
     r = xrtm_set_fourier_tol(d, fourier_tol);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_fourier_tol()");
     return;
}


void IDL_CDECL xrtm_get_fourier_tol_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     double r;
     xrtm_data *d;
     IDL_VARIABLE var;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     r = xrtm_get_fourier_tol(d);
     if (r == XRTM_DBL_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_fourier_tol()");
     var.type = IDL_TYP_DOUBLE;
     var.flags = 0;
     var.value.d = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_fourier_tol()");
     IDL_VarCopy((IDL_VPTR) &var, argv[1]);
     return;
}


void IDL_CDECL xrtm_set_lambda_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     double lambda;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_DOUBLE && argv[1]->type != IDL_TYP_FLOAT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: lambda must be of type double or float");
     if (argv[1]->type == IDL_TYP_DOUBLE)
          lambda = argv[1]->value.d;
     else
          lambda = argv[1]->value.f;
     r = xrtm_set_lambda(d, lambda);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_lambda()");
     return;
}


void IDL_CDECL xrtm_get_lambda_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     double r;
     xrtm_data *d;
     IDL_VARIABLE var;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     r = xrtm_get_lambda(d);
     if (r == XRTM_DBL_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_lambda()");
     var.type = IDL_TYP_DOUBLE;
     var.flags = 0;
     var.value.d = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_lambda()");
     IDL_VarCopy((IDL_VPTR) &var, argv[1]);
     return;
}


void IDL_CDECL xrtm_set_planet_r_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     double planet_r;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_DOUBLE && argv[1]->type != IDL_TYP_FLOAT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: planet_r must be of type double or float");
     if (argv[1]->type == IDL_TYP_DOUBLE)
          planet_r = argv[1]->value.d;
     else
          planet_r = argv[1]->value.f;
     r = xrtm_set_planet_r(d, planet_r);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_planet_r()");
     return;
}


void IDL_CDECL xrtm_get_planet_r_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     double r;
     xrtm_data *d;
     IDL_VARIABLE var;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     r = xrtm_get_planet_r(d);
     if (r == XRTM_DBL_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_planet_r()");
     var.type = IDL_TYP_DOUBLE;
     var.flags = 0;
     var.value.d = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_planet_r()");
     IDL_VarCopy((IDL_VPTR) &var, argv[1]);
     return;
}


void IDL_CDECL xrtm_set_levels_z_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     double *levels_z;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_ARRAY(argv[1]);
     if (argv[1]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: levels_z must be of type double");
     if (argv[1]->value.arr->n_dim != 1)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: levels_z must be an array with 2 dimensions");
     if (argv[1]->value.arr->dim[0] != (d->n_layers + 1))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: levels_z dimension 1 must have d->n_layers + 1 elements");
     levels_z = (double *) argv[1]->value.arr->data;
     r = xrtm_set_levels_z(d, levels_z);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_levels_z()");
     return;
}


void IDL_CDECL xrtm_get_levels_z_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     IDL_VPTR ptr;
     IDL_MEMINT dim_idl[16];
     double *levels_z;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     levels_z = malloc((d->n_layers + 1) * sizeof(double));
     r = xrtm_get_levels_z(d, levels_z);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_levels_z()");
     dim_idl[0] = d->n_layers + 1;
     ptr = IDL_ImportArray(1, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) levels_z, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[1]);
     return;
}


void IDL_CDECL xrtm_set_out_levels_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     int *out_levels;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_ARRAY(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: out_levels must be of type long");
     if (argv[1]->value.arr->n_dim != 1)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: out_levels must be an array with 2 dimensions");
     if (argv[1]->value.arr->dim[0] != (d->n_ulevels))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: out_levels dimension 1 must have d->n_ulevels elements");
     out_levels = (int *) argv[1]->value.arr->data;
     r = xrtm_set_out_levels(d, out_levels);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_out_levels()");
     return;
}


void IDL_CDECL xrtm_get_out_levels_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     IDL_VPTR ptr;
     IDL_MEMINT dim_idl[16];
     int *out_levels;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     out_levels = malloc((d->n_ulevels) * sizeof(int));
     r = xrtm_get_out_levels(d, out_levels);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_out_levels()");
     dim_idl[0] = d->n_ulevels;
     ptr = IDL_ImportArray(1, (IDL_MEMINT *) dim_idl, IDL_TYP_LONG, (UCHAR *) out_levels, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[1]);
     return;
}


void IDL_CDECL xrtm_set_out_taus_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     double *out_taus;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_ARRAY(argv[1]);
     if (argv[1]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: out_taus must be of type double");
     if (argv[1]->value.arr->n_dim != 1)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: out_taus must be an array with 2 dimensions");
     if (argv[1]->value.arr->dim[0] != (d->n_ulevels))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: out_taus dimension 1 must have d->n_ulevels elements");
     out_taus = (double *) argv[1]->value.arr->data;
     r = xrtm_set_out_taus(d, out_taus);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_out_taus()");
     return;
}


void IDL_CDECL xrtm_get_out_taus_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     IDL_VPTR ptr;
     IDL_MEMINT dim_idl[16];
     double *out_taus;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     out_taus = malloc((d->n_ulevels) * sizeof(double));
     r = xrtm_get_out_taus(d, out_taus);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_out_taus()");
     dim_idl[0] = d->n_ulevels;
     ptr = IDL_ImportArray(1, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) out_taus, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[1]);
     return;
}


void IDL_CDECL xrtm_set_out_thetas_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     double *out_thetas;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_ARRAY(argv[1]);
     if (argv[1]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: out_thetas must be of type double");
     if (argv[1]->value.arr->n_dim != 1)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: out_thetas must be an array with 2 dimensions");
     if (argv[1]->value.arr->dim[0] != (d->n_umus))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: out_thetas dimension 1 must have d->n_umus elements");
     out_thetas = (double *) argv[1]->value.arr->data;
     r = xrtm_set_out_thetas(d, out_thetas);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_out_thetas()");
     return;
}


void IDL_CDECL xrtm_get_out_thetas_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     IDL_VPTR ptr;
     IDL_MEMINT dim_idl[16];
     double *out_thetas;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     out_thetas = malloc((d->n_umus) * sizeof(double));
     r = xrtm_get_out_thetas(d, out_thetas);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_out_thetas()");
     dim_idl[0] = d->n_umus;
     ptr = IDL_ImportArray(1, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) out_thetas, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[1]);
     return;
}


void IDL_CDECL xrtm_set_F_iso_top_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     double F_iso_top;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_DOUBLE && argv[1]->type != IDL_TYP_FLOAT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: F_iso_top must be of type double or float");
     if (argv[1]->type == IDL_TYP_DOUBLE)
          F_iso_top = argv[1]->value.d;
     else
          F_iso_top = argv[1]->value.f;
     r = xrtm_set_F_iso_top(d, F_iso_top);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_F_iso_top()");
     return;
}


void IDL_CDECL xrtm_get_F_iso_top_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     double r;
     xrtm_data *d;
     IDL_VARIABLE var;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     r = xrtm_get_F_iso_top(d);
     if (r == XRTM_DBL_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_F_iso_top()");
     var.type = IDL_TYP_DOUBLE;
     var.flags = 0;
     var.value.d = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_F_iso_top()");
     IDL_VarCopy((IDL_VPTR) &var, argv[1]);
     return;
}


void IDL_CDECL xrtm_set_F_iso_top_l_1_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     int i_deriv;
     double F_iso_top_l;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_deriv must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_deriv = argv[1]->value.l;
     else
          i_deriv = argv[1]->value.i;
     IDL_ENSURE_SCALAR(argv[2]);
     if (argv[2]->type != IDL_TYP_DOUBLE && argv[2]->type != IDL_TYP_FLOAT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: F_iso_top_l must be of type double or float");
     if (argv[2]->type == IDL_TYP_DOUBLE)
          F_iso_top_l = argv[2]->value.d;
     else
          F_iso_top_l = argv[2]->value.f;
     r = xrtm_set_F_iso_top_l_1(d, i_deriv, F_iso_top_l);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_F_iso_top_l_1()");
     return;
}


void IDL_CDECL xrtm_set_F_iso_top_l_n_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     double *F_iso_top_l;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_ARRAY(argv[1]);
     if (argv[1]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: F_iso_top_l must be of type double");
     if (argv[1]->value.arr->n_dim != 1)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: F_iso_top_l must be an array with 2 dimensions");
     if (argv[1]->value.arr->dim[0] != (d->n_derivs))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: F_iso_top_l dimension 1 must have d->n_derivs elements");
     F_iso_top_l = (double *) argv[1]->value.arr->data;
     r = xrtm_set_F_iso_top_l_n(d, F_iso_top_l);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_F_iso_top_l_n()");
     return;
}


void IDL_CDECL xrtm_get_F_iso_top_l_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     double r;
     xrtm_data *d;
     IDL_VARIABLE var;
     int i_deriv;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_deriv must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_deriv = argv[1]->value.l;
     else
          i_deriv = argv[1]->value.i;
     r = xrtm_get_F_iso_top_l(d, i_deriv);
     if (r == XRTM_DBL_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_F_iso_top_l()");
     var.type = IDL_TYP_DOUBLE;
     var.flags = 0;
     var.value.d = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_F_iso_top_l()");
     IDL_VarCopy((IDL_VPTR) &var, argv[2]);
     return;
}


void IDL_CDECL xrtm_set_F_iso_bot_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     double F_iso_bot;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_DOUBLE && argv[1]->type != IDL_TYP_FLOAT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: F_iso_bot must be of type double or float");
     if (argv[1]->type == IDL_TYP_DOUBLE)
          F_iso_bot = argv[1]->value.d;
     else
          F_iso_bot = argv[1]->value.f;
     r = xrtm_set_F_iso_bot(d, F_iso_bot);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_F_iso_bot()");
     return;
}


void IDL_CDECL xrtm_get_F_iso_bot_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     double r;
     xrtm_data *d;
     IDL_VARIABLE var;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     r = xrtm_get_F_iso_bot(d);
     if (r == XRTM_DBL_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_F_iso_bot()");
     var.type = IDL_TYP_DOUBLE;
     var.flags = 0;
     var.value.d = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_F_iso_bot()");
     IDL_VarCopy((IDL_VPTR) &var, argv[1]);
     return;
}


void IDL_CDECL xrtm_set_F_iso_bot_l_1_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     int i_deriv;
     double F_iso_bot_l;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_deriv must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_deriv = argv[1]->value.l;
     else
          i_deriv = argv[1]->value.i;
     IDL_ENSURE_SCALAR(argv[2]);
     if (argv[2]->type != IDL_TYP_DOUBLE && argv[2]->type != IDL_TYP_FLOAT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: F_iso_bot_l must be of type double or float");
     if (argv[2]->type == IDL_TYP_DOUBLE)
          F_iso_bot_l = argv[2]->value.d;
     else
          F_iso_bot_l = argv[2]->value.f;
     r = xrtm_set_F_iso_bot_l_1(d, i_deriv, F_iso_bot_l);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_F_iso_bot_l_1()");
     return;
}


void IDL_CDECL xrtm_set_F_iso_bot_l_n_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     double *F_iso_bot_l;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_ARRAY(argv[1]);
     if (argv[1]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: F_iso_bot_l must be of type double");
     if (argv[1]->value.arr->n_dim != 1)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: F_iso_bot_l must be an array with 2 dimensions");
     if (argv[1]->value.arr->dim[0] != (d->n_derivs))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: F_iso_bot_l dimension 1 must have d->n_derivs elements");
     F_iso_bot_l = (double *) argv[1]->value.arr->data;
     r = xrtm_set_F_iso_bot_l_n(d, F_iso_bot_l);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_F_iso_bot_l_n()");
     return;
}


void IDL_CDECL xrtm_get_F_iso_bot_l_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     double r;
     xrtm_data *d;
     IDL_VARIABLE var;
     int i_deriv;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_deriv must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_deriv = argv[1]->value.l;
     else
          i_deriv = argv[1]->value.i;
     r = xrtm_get_F_iso_bot_l(d, i_deriv);
     if (r == XRTM_DBL_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_F_iso_bot_l()");
     var.type = IDL_TYP_DOUBLE;
     var.flags = 0;
     var.value.d = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_F_iso_bot_l()");
     IDL_VarCopy((IDL_VPTR) &var, argv[2]);
     return;
}


void IDL_CDECL xrtm_set_F_0_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     double F_0;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_DOUBLE && argv[1]->type != IDL_TYP_FLOAT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: F_0 must be of type double or float");
     if (argv[1]->type == IDL_TYP_DOUBLE)
          F_0 = argv[1]->value.d;
     else
          F_0 = argv[1]->value.f;
     r = xrtm_set_F_0(d, F_0);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_F_0()");
     return;
}


void IDL_CDECL xrtm_get_F_0_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     double r;
     xrtm_data *d;
     IDL_VARIABLE var;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     r = xrtm_get_F_0(d);
     if (r == XRTM_DBL_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_F_0()");
     var.type = IDL_TYP_DOUBLE;
     var.flags = 0;
     var.value.d = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_F_0()");
     IDL_VarCopy((IDL_VPTR) &var, argv[1]);
     return;
}


void IDL_CDECL xrtm_set_theta_0_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     double theta_0;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_DOUBLE && argv[1]->type != IDL_TYP_FLOAT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: theta_0 must be of type double or float");
     if (argv[1]->type == IDL_TYP_DOUBLE)
          theta_0 = argv[1]->value.d;
     else
          theta_0 = argv[1]->value.f;
     r = xrtm_set_theta_0(d, theta_0);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_theta_0()");
     return;
}


void IDL_CDECL xrtm_get_theta_0_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     double r;
     xrtm_data *d;
     IDL_VARIABLE var;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     r = xrtm_get_theta_0(d);
     if (r == XRTM_DBL_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_theta_0()");
     var.type = IDL_TYP_DOUBLE;
     var.flags = 0;
     var.value.d = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_theta_0()");
     IDL_VarCopy((IDL_VPTR) &var, argv[1]);
     return;
}


void IDL_CDECL xrtm_set_phi_0_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     double phi_0;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_DOUBLE && argv[1]->type != IDL_TYP_FLOAT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: phi_0 must be of type double or float");
     if (argv[1]->type == IDL_TYP_DOUBLE)
          phi_0 = argv[1]->value.d;
     else
          phi_0 = argv[1]->value.f;
     r = xrtm_set_phi_0(d, phi_0);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_phi_0()");
     return;
}


void IDL_CDECL xrtm_get_phi_0_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     double r;
     xrtm_data *d;
     IDL_VARIABLE var;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     r = xrtm_get_phi_0(d);
     if (r == XRTM_DBL_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_phi_0()");
     var.type = IDL_TYP_DOUBLE;
     var.flags = 0;
     var.value.d = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_phi_0()");
     IDL_VarCopy((IDL_VPTR) &var, argv[1]);
     return;
}


void IDL_CDECL xrtm_set_levels_b_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     double *levels_b;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_ARRAY(argv[1]);
     if (argv[1]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: levels_b must be of type double");
     if (argv[1]->value.arr->n_dim != 1)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: levels_b must be an array with 2 dimensions");
     if (argv[1]->value.arr->dim[0] != (d->n_ulevels))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: levels_b dimension 1 must have d->n_ulevels elements");
     levels_b = (double *) argv[1]->value.arr->data;
     r = xrtm_set_levels_b(d, levels_b);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_levels_b()");
     return;
}


void IDL_CDECL xrtm_get_levels_b_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     IDL_VPTR ptr;
     IDL_MEMINT dim_idl[16];
     double *levels_b;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     levels_b = malloc((d->n_ulevels) * sizeof(double));
     r = xrtm_get_levels_b(d, levels_b);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_levels_b()");
     dim_idl[0] = d->n_ulevels;
     ptr = IDL_ImportArray(1, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) levels_b, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[1]);
     return;
}


void IDL_CDECL xrtm_set_levels_b_l_1_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     int i_deriv;
     double *levels_b_l;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_deriv must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_deriv = argv[1]->value.l;
     else
          i_deriv = argv[1]->value.i;
     IDL_ENSURE_ARRAY(argv[2]);
     if (argv[2]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: levels_b_l must be of type double");
     if (argv[2]->value.arr->n_dim != 1)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: levels_b_l must be an array with 2 dimensions");
     if (argv[2]->value.arr->dim[0] != (d->n_derivs))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: levels_b_l dimension 1 must have d->n_derivs elements");
     levels_b_l = (double *) argv[2]->value.arr->data;
     r = xrtm_set_levels_b_l_1(d, i_deriv, levels_b_l);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_levels_b_l_1()");
     return;
}


void IDL_CDECL xrtm_set_levels_b_l_n_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     size_t dim[16];
     xrtm_data *d;
     double **levels_b_l;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_ARRAY(argv[1]);
     if (argv[1]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: levels_b_l must be of type double");
     if (argv[1]->value.arr->n_dim != 2)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: levels_b_l must be an array with 2 dimensions");
     if (argv[1]->value.arr->dim[1] != (d->n_layers + 1))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: levels_b_l dimension 2 must have d->n_layers + 1 elements");
     if (argv[1]->value.arr->dim[0] != (d->n_derivs))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: levels_b_l dimension 1 must have d->n_derivs elements");
     dim[0] = d->n_layers + 1;
     dim[1] = d->n_derivs;
     levels_b_l = (double **) array_from_mem((void *) argv[1]->value.arr->data, 2, dim, sizeof(double), 1);
     r = xrtm_set_levels_b_l_n(d, levels_b_l);
     free_array((void *) levels_b_l, 2);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_levels_b_l_n()");
     return;
}


void IDL_CDECL xrtm_get_levels_b_l_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     IDL_VPTR ptr;
     IDL_MEMINT dim_idl[16];
     int i_deriv;
     double *levels_b_l;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_deriv must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_deriv = argv[1]->value.l;
     else
          i_deriv = argv[1]->value.i;
     levels_b_l = malloc((d->n_layers + 1) * sizeof(double));
     r = xrtm_get_levels_b_l(d, i_deriv, levels_b_l);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_levels_b_l()");
     dim_idl[0] = d->n_layers + 1;
     ptr = IDL_ImportArray(1, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) levels_b_l, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[2]);
     return;
}


void IDL_CDECL xrtm_set_surface_b_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     double surface_b;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_DOUBLE && argv[1]->type != IDL_TYP_FLOAT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: surface_b must be of type double or float");
     if (argv[1]->type == IDL_TYP_DOUBLE)
          surface_b = argv[1]->value.d;
     else
          surface_b = argv[1]->value.f;
     r = xrtm_set_surface_b(d, surface_b);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_surface_b()");
     return;
}


void IDL_CDECL xrtm_get_surface_b_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     double r;
     xrtm_data *d;
     IDL_VARIABLE var;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     r = xrtm_get_surface_b(d);
     if (r == XRTM_DBL_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_surface_b()");
     var.type = IDL_TYP_DOUBLE;
     var.flags = 0;
     var.value.d = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_surface_b()");
     IDL_VarCopy((IDL_VPTR) &var, argv[1]);
     return;
}


void IDL_CDECL xrtm_set_surface_b_l_1_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     int i_deriv;
     double surface_b_l;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_deriv must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_deriv = argv[1]->value.l;
     else
          i_deriv = argv[1]->value.i;
     IDL_ENSURE_SCALAR(argv[2]);
     if (argv[2]->type != IDL_TYP_DOUBLE && argv[2]->type != IDL_TYP_FLOAT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: surface_b_l must be of type double or float");
     if (argv[2]->type == IDL_TYP_DOUBLE)
          surface_b_l = argv[2]->value.d;
     else
          surface_b_l = argv[2]->value.f;
     r = xrtm_set_surface_b_l_1(d, i_deriv, surface_b_l);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_surface_b_l_1()");
     return;
}


void IDL_CDECL xrtm_set_surface_b_l_n_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     double *surface_b_l;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_ARRAY(argv[1]);
     if (argv[1]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: surface_b_l must be of type double");
     if (argv[1]->value.arr->n_dim != 1)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: surface_b_l must be an array with 2 dimensions");
     if (argv[1]->value.arr->dim[0] != (d->n_derivs))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: surface_b_l dimension 1 must have d->n_derivs elements");
     surface_b_l = (double *) argv[1]->value.arr->data;
     r = xrtm_set_surface_b_l_n(d, surface_b_l);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_surface_b_l_n()");
     return;
}


void IDL_CDECL xrtm_get_surface_b_l_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     double r;
     xrtm_data *d;
     IDL_VARIABLE var;
     int i_deriv;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_deriv must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_deriv = argv[1]->value.l;
     else
          i_deriv = argv[1]->value.i;
     r = xrtm_get_surface_b_l(d, i_deriv);
     if (r == XRTM_DBL_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_surface_b_l()");
     var.type = IDL_TYP_DOUBLE;
     var.flags = 0;
     var.value.d = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_surface_b_l()");
     IDL_VarCopy((IDL_VPTR) &var, argv[2]);
     return;
}


void IDL_CDECL xrtm_set_g_1_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     int i_layer;
     double g;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_layer must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_layer = argv[1]->value.l;
     else
          i_layer = argv[1]->value.i;
     IDL_ENSURE_SCALAR(argv[2]);
     if (argv[2]->type != IDL_TYP_DOUBLE && argv[2]->type != IDL_TYP_FLOAT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: g must be of type double or float");
     if (argv[2]->type == IDL_TYP_DOUBLE)
          g = argv[2]->value.d;
     else
          g = argv[2]->value.f;
     r = xrtm_set_g_1(d, i_layer, g);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_g_1()");
     return;
}


void IDL_CDECL xrtm_set_g_n_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     double *g;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_ARRAY(argv[1]);
     if (argv[1]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: g must be of type double");
     if (argv[1]->value.arr->n_dim != 1)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: g must be an array with 2 dimensions");
     if (argv[1]->value.arr->dim[0] != (d->n_layers))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: g dimension 1 must have d->n_layers elements");
     g = (double *) argv[1]->value.arr->data;
     r = xrtm_set_g_n(d, g);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_g_n()");
     return;
}


void IDL_CDECL xrtm_get_g_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     double r;
     xrtm_data *d;
     IDL_VARIABLE var;
     int i_layer;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_layer must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_layer = argv[1]->value.l;
     else
          i_layer = argv[1]->value.i;
     r = xrtm_get_g(d, i_layer);
     if (r == XRTM_DBL_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_g()");
     var.type = IDL_TYP_DOUBLE;
     var.flags = 0;
     var.value.d = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_g()");
     IDL_VarCopy((IDL_VPTR) &var, argv[2]);
     return;
}


void IDL_CDECL xrtm_set_g_l_11_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     int i_layer;
     int i_deriv;
     double g_l;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_layer must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_layer = argv[1]->value.l;
     else
          i_layer = argv[1]->value.i;
     IDL_ENSURE_SCALAR(argv[2]);
     if (argv[2]->type != IDL_TYP_LONG && argv[2]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_deriv must be of type long or int");
     if (argv[2]->type == IDL_TYP_LONG)
          i_deriv = argv[2]->value.l;
     else
          i_deriv = argv[2]->value.i;
     IDL_ENSURE_SCALAR(argv[3]);
     if (argv[3]->type != IDL_TYP_DOUBLE && argv[3]->type != IDL_TYP_FLOAT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: g_l must be of type double or float");
     if (argv[3]->type == IDL_TYP_DOUBLE)
          g_l = argv[3]->value.d;
     else
          g_l = argv[3]->value.f;
     r = xrtm_set_g_l_11(d, i_layer, i_deriv, g_l);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_g_l_11()");
     return;
}


void IDL_CDECL xrtm_set_g_l_n1_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     int i_deriv;
     double *g_l;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_deriv must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_deriv = argv[1]->value.l;
     else
          i_deriv = argv[1]->value.i;
     IDL_ENSURE_ARRAY(argv[2]);
     if (argv[2]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: g_l must be of type double");
     if (argv[2]->value.arr->n_dim != 1)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: g_l must be an array with 2 dimensions");
     if (argv[2]->value.arr->dim[0] != (d->n_layers))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: g_l dimension 1 must have d->n_layers elements");
     g_l = (double *) argv[2]->value.arr->data;
     r = xrtm_set_g_l_n1(d, i_deriv, g_l);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_g_l_n1()");
     return;
}


void IDL_CDECL xrtm_set_g_l_1n_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     int i_layer;
     double *g_l;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_layer must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_layer = argv[1]->value.l;
     else
          i_layer = argv[1]->value.i;
     IDL_ENSURE_ARRAY(argv[2]);
     if (argv[2]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: g_l must be of type double");
     if (argv[2]->value.arr->n_dim != 1)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: g_l must be an array with 2 dimensions");
     if (argv[2]->value.arr->dim[0] != (d->n_derivs))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: g_l dimension 1 must have d->n_derivs elements");
     g_l = (double *) argv[2]->value.arr->data;
     r = xrtm_set_g_l_1n(d, i_layer, g_l);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_g_l_1n()");
     return;
}


void IDL_CDECL xrtm_set_g_l_nn_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     size_t dim[16];
     xrtm_data *d;
     double **g_l;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_ARRAY(argv[1]);
     if (argv[1]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: g_l must be of type double");
     if (argv[1]->value.arr->n_dim != 2)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: g_l must be an array with 2 dimensions");
     if (argv[1]->value.arr->dim[1] != (d->n_layers))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: g_l dimension 2 must have d->n_layers elements");
     if (argv[1]->value.arr->dim[0] != (d->n_derivs))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: g_l dimension 1 must have d->n_derivs elements");
     dim[0] = d->n_layers;
     dim[1] = d->n_derivs;
     g_l = (double **) array_from_mem((void *) argv[1]->value.arr->data, 2, dim, sizeof(double), 1);
     r = xrtm_set_g_l_nn(d, g_l);
     free_array((void *) g_l, 2);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_g_l_nn()");
     return;
}


void IDL_CDECL xrtm_get_g_l_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     double r;
     xrtm_data *d;
     IDL_VARIABLE var;
     int i_layer;
     int i_deriv;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_layer must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_layer = argv[1]->value.l;
     else
          i_layer = argv[1]->value.i;
     IDL_ENSURE_SCALAR(argv[2]);
     if (argv[2]->type != IDL_TYP_LONG && argv[2]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_deriv must be of type long or int");
     if (argv[2]->type == IDL_TYP_LONG)
          i_deriv = argv[2]->value.l;
     else
          i_deriv = argv[2]->value.i;
     r = xrtm_get_g_l(d, i_layer, i_deriv);
     if (r == XRTM_DBL_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_g_l()");
     var.type = IDL_TYP_DOUBLE;
     var.flags = 0;
     var.value.d = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_g_l()");
     IDL_VarCopy((IDL_VPTR) &var, argv[3]);
     return;
}


void IDL_CDECL xrtm_set_coef_1_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     size_t dim[16];
     xrtm_data *d;
     int i_layer;
     int n_coef_layer;
     double **coef;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_layer must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_layer = argv[1]->value.l;
     else
          i_layer = argv[1]->value.i;
     IDL_ENSURE_SCALAR(argv[2]);
     if (argv[2]->type != IDL_TYP_LONG && argv[2]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: n_coef_layer must be of type long or int");
     if (argv[2]->type == IDL_TYP_LONG)
          n_coef_layer = argv[2]->value.l;
     else
          n_coef_layer = argv[2]->value.i;
     IDL_ENSURE_ARRAY(argv[3]);
     if (argv[3]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: coef must be of type double");
     if (argv[3]->value.arr->n_dim != 2)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: coef must be an array with 2 dimensions");
     if (argv[3]->value.arr->dim[1] != (d->n_elem))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: coef dimension 2 must have d->n_elem elements");
     if (argv[3]->value.arr->dim[0] != (n_coef_layer))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: coef dimension 1 must have n_coef_layer elements");
     dim[0] = d->n_elem;
     dim[1] = n_coef_layer;
     coef = (double **) array_from_mem((void *) argv[3]->value.arr->data, 2, dim, sizeof(double), 1);
     r = xrtm_set_coef_1(d, i_layer, n_coef_layer, coef);
     free_array((void *) coef, 2);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_coef_1()");
     return;
}


void IDL_CDECL xrtm_set_coef_n_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     size_t dim[16];
     xrtm_data *d;
     int *n_coef_layer;
     double ***coef;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_ARRAY(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: n_coef_layer must be of type long");
     if (argv[1]->value.arr->n_dim != 1)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: n_coef_layer must be an array with 2 dimensions");
     if (argv[1]->value.arr->dim[0] != (d->n_layers))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: n_coef_layer dimension 1 must have d->n_layers elements");
     n_coef_layer = (int *) argv[1]->value.arr->data;
     IDL_ENSURE_ARRAY(argv[2]);
     if (argv[2]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: coef must be of type double");
     if (argv[2]->value.arr->n_dim != 3)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: coef must be an array with 2 dimensions");
     if (argv[2]->value.arr->dim[2] != (d->n_layers))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: coef dimension 3 must have d->n_layers elements");
     if (argv[2]->value.arr->dim[1] != (d->n_elem))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: coef dimension 2 must have d->n_elem elements");
     if (argv[2]->value.arr->dim[0] != (d->n_coef))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: coef dimension 1 must have d->n_coef elements");
     dim[0] = d->n_layers;
     dim[1] = d->n_elem;
     dim[2] = d->n_coef;
     coef = (double ***) array_from_mem((void *) argv[2]->value.arr->data, 3, dim, sizeof(double), 1);
     r = xrtm_set_coef_n(d, n_coef_layer, coef);
     free_array((void *) coef, 3);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_coef_n()");
     return;
}


void IDL_CDECL xrtm_get_n_coef_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     IDL_VARIABLE var;
     int i_layer;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_layer must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_layer = argv[1]->value.l;
     else
          i_layer = argv[1]->value.i;
     r = xrtm_get_n_coef(d, i_layer);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_n_coef()");
     var.type = IDL_TYP_LONG;
     var.flags = 0;
     var.value.l = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_n_coef()");
     IDL_VarCopy((IDL_VPTR) &var, argv[2]);
     return;
}


void IDL_CDECL xrtm_get_coef_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     double r;
     xrtm_data *d;
     IDL_VARIABLE var;
     int i_layer;
     int i_elem;
     int i_coef;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_layer must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_layer = argv[1]->value.l;
     else
          i_layer = argv[1]->value.i;
     IDL_ENSURE_SCALAR(argv[2]);
     if (argv[2]->type != IDL_TYP_LONG && argv[2]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_elem must be of type long or int");
     if (argv[2]->type == IDL_TYP_LONG)
          i_elem = argv[2]->value.l;
     else
          i_elem = argv[2]->value.i;
     IDL_ENSURE_SCALAR(argv[3]);
     if (argv[3]->type != IDL_TYP_LONG && argv[3]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_coef must be of type long or int");
     if (argv[3]->type == IDL_TYP_LONG)
          i_coef = argv[3]->value.l;
     else
          i_coef = argv[3]->value.i;
     r = xrtm_get_coef(d, i_layer, i_elem, i_coef);
     if (r == XRTM_DBL_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_coef()");
     var.type = IDL_TYP_DOUBLE;
     var.flags = 0;
     var.value.d = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_coef()");
     IDL_VarCopy((IDL_VPTR) &var, argv[4]);
     return;
}


void IDL_CDECL xrtm_set_coef_l_11_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     size_t dim[16];
     xrtm_data *d;
     int i_layer;
     int i_deriv;
     double **coef_l;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_layer must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_layer = argv[1]->value.l;
     else
          i_layer = argv[1]->value.i;
     IDL_ENSURE_SCALAR(argv[2]);
     if (argv[2]->type != IDL_TYP_LONG && argv[2]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_deriv must be of type long or int");
     if (argv[2]->type == IDL_TYP_LONG)
          i_deriv = argv[2]->value.l;
     else
          i_deriv = argv[2]->value.i;
     IDL_ENSURE_ARRAY(argv[3]);
     if (argv[3]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: coef_l must be of type double");
     if (argv[3]->value.arr->n_dim != 2)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: coef_l must be an array with 2 dimensions");
     if (argv[3]->value.arr->dim[1] != (d->n_elem))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: coef_l dimension 2 must have d->n_elem elements");
     if (argv[3]->value.arr->dim[0] != (d->n_coef_layer[i_layer]))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: coef_l dimension 1 must have d->n_coef_layer[i_layer] elements");
     dim[0] = d->n_elem;
     dim[1] = d->n_coef_layer[i_layer];
     coef_l = (double **) array_from_mem((void *) argv[3]->value.arr->data, 2, dim, sizeof(double), 1);
     r = xrtm_set_coef_l_11(d, i_layer, i_deriv, coef_l);
     free_array((void *) coef_l, 2);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_coef_l_11()");
     return;
}


void IDL_CDECL xrtm_set_coef_l_n1_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     size_t dim[16];
     xrtm_data *d;
     int i_deriv;
     double ***coef_l;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_deriv must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_deriv = argv[1]->value.l;
     else
          i_deriv = argv[1]->value.i;
     IDL_ENSURE_ARRAY(argv[2]);
     if (argv[2]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: coef_l must be of type double");
     if (argv[2]->value.arr->n_dim != 3)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: coef_l must be an array with 2 dimensions");
     if (argv[2]->value.arr->dim[2] != (d->n_layers))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: coef_l dimension 3 must have d->n_layers elements");
     if (argv[2]->value.arr->dim[1] != (d->n_elem))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: coef_l dimension 2 must have d->n_elem elements");
     if (argv[2]->value.arr->dim[0] != (d->n_coef))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: coef_l dimension 1 must have d->n_coef elements");
     dim[0] = d->n_layers;
     dim[1] = d->n_elem;
     dim[2] = d->n_coef;
     coef_l = (double ***) array_from_mem((void *) argv[2]->value.arr->data, 3, dim, sizeof(double), 1);
     r = xrtm_set_coef_l_n1(d, i_deriv, coef_l);
     free_array((void *) coef_l, 3);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_coef_l_n1()");
     return;
}


void IDL_CDECL xrtm_set_coef_l_1n_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     size_t dim[16];
     xrtm_data *d;
     int i_layer;
     double ***coef_l;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_layer must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_layer = argv[1]->value.l;
     else
          i_layer = argv[1]->value.i;
     IDL_ENSURE_ARRAY(argv[2]);
     if (argv[2]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: coef_l must be of type double");
     if (argv[2]->value.arr->n_dim != 3)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: coef_l must be an array with 2 dimensions");
     if (argv[2]->value.arr->dim[2] != (d->n_derivs))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: coef_l dimension 3 must have d->n_derivs elements");
     if (argv[2]->value.arr->dim[1] != (d->n_elem))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: coef_l dimension 2 must have d->n_elem elements");
     if (argv[2]->value.arr->dim[0] != (d->n_coef_layer[i_layer]))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: coef_l dimension 1 must have d->n_coef_layer[i_layer] elements");
     dim[0] = d->n_derivs;
     dim[1] = d->n_elem;
     dim[2] = d->n_coef_layer[i_layer];
     coef_l = (double ***) array_from_mem((void *) argv[2]->value.arr->data, 3, dim, sizeof(double), 1);
     r = xrtm_set_coef_l_1n(d, i_layer, coef_l);
     free_array((void *) coef_l, 3);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_coef_l_1n()");
     return;
}


void IDL_CDECL xrtm_set_coef_l_nn_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     size_t dim[16];
     xrtm_data *d;
     double ****coef_l;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_ARRAY(argv[1]);
     if (argv[1]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: coef_l must be of type double");
     if (argv[1]->value.arr->n_dim != 4)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: coef_l must be an array with 2 dimensions");
     if (argv[1]->value.arr->dim[3] != (d->n_layers))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: coef_l dimension 4 must have d->n_layers elements");
     if (argv[1]->value.arr->dim[2] != (d->n_derivs))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: coef_l dimension 3 must have d->n_derivs elements");
     if (argv[1]->value.arr->dim[1] != (d->n_elem))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: coef_l dimension 2 must have d->n_elem elements");
     if (argv[1]->value.arr->dim[0] != (d->n_coef))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: coef_l dimension 1 must have d->n_coef elements");
     dim[0] = d->n_layers;
     dim[1] = d->n_derivs;
     dim[2] = d->n_elem;
     dim[3] = d->n_coef;
     coef_l = (double ****) array_from_mem((void *) argv[1]->value.arr->data, 4, dim, sizeof(double), 1);
     r = xrtm_set_coef_l_nn(d, coef_l);
     free_array((void *) coef_l, 4);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_coef_l_nn()");
     return;
}


void IDL_CDECL xrtm_get_coef_l_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     double r;
     xrtm_data *d;
     IDL_VARIABLE var;
     int i_layer;
     int i_deriv;
     int i_elem;
     int i_coef;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_layer must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_layer = argv[1]->value.l;
     else
          i_layer = argv[1]->value.i;
     IDL_ENSURE_SCALAR(argv[2]);
     if (argv[2]->type != IDL_TYP_LONG && argv[2]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_deriv must be of type long or int");
     if (argv[2]->type == IDL_TYP_LONG)
          i_deriv = argv[2]->value.l;
     else
          i_deriv = argv[2]->value.i;
     IDL_ENSURE_SCALAR(argv[3]);
     if (argv[3]->type != IDL_TYP_LONG && argv[3]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_elem must be of type long or int");
     if (argv[3]->type == IDL_TYP_LONG)
          i_elem = argv[3]->value.l;
     else
          i_elem = argv[3]->value.i;
     IDL_ENSURE_SCALAR(argv[4]);
     if (argv[4]->type != IDL_TYP_LONG && argv[4]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_coef must be of type long or int");
     if (argv[4]->type == IDL_TYP_LONG)
          i_coef = argv[4]->value.l;
     else
          i_coef = argv[4]->value.i;
     r = xrtm_get_coef_l(d, i_layer, i_deriv, i_elem, i_coef);
     if (r == XRTM_DBL_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_coef_l()");
     var.type = IDL_TYP_DOUBLE;
     var.flags = 0;
     var.value.d = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_coef_l()");
     IDL_VarCopy((IDL_VPTR) &var, argv[5]);
     return;
}


void IDL_CDECL xrtm_set_omega_1_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     int i_layer;
     double omega;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_layer must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_layer = argv[1]->value.l;
     else
          i_layer = argv[1]->value.i;
     IDL_ENSURE_SCALAR(argv[2]);
     if (argv[2]->type != IDL_TYP_DOUBLE && argv[2]->type != IDL_TYP_FLOAT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: omega must be of type double or float");
     if (argv[2]->type == IDL_TYP_DOUBLE)
          omega = argv[2]->value.d;
     else
          omega = argv[2]->value.f;
     r = xrtm_set_omega_1(d, i_layer, omega);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_omega_1()");
     return;
}


void IDL_CDECL xrtm_set_omega_n_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     double *omega;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_ARRAY(argv[1]);
     if (argv[1]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: omega must be of type double");
     if (argv[1]->value.arr->n_dim != 1)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: omega must be an array with 2 dimensions");
     if (argv[1]->value.arr->dim[0] != (d->n_layers))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: omega dimension 1 must have d->n_layers elements");
     omega = (double *) argv[1]->value.arr->data;
     r = xrtm_set_omega_n(d, omega);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_omega_n()");
     return;
}


void IDL_CDECL xrtm_get_omega_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     double r;
     xrtm_data *d;
     IDL_VARIABLE var;
     int i_layer;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_layer must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_layer = argv[1]->value.l;
     else
          i_layer = argv[1]->value.i;
     r = xrtm_get_omega(d, i_layer);
     if (r == XRTM_DBL_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_omega()");
     var.type = IDL_TYP_DOUBLE;
     var.flags = 0;
     var.value.d = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_omega()");
     IDL_VarCopy((IDL_VPTR) &var, argv[2]);
     return;
}


void IDL_CDECL xrtm_set_omega_l_11_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     int i_layer;
     int i_deriv;
     double omega_l;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_layer must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_layer = argv[1]->value.l;
     else
          i_layer = argv[1]->value.i;
     IDL_ENSURE_SCALAR(argv[2]);
     if (argv[2]->type != IDL_TYP_LONG && argv[2]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_deriv must be of type long or int");
     if (argv[2]->type == IDL_TYP_LONG)
          i_deriv = argv[2]->value.l;
     else
          i_deriv = argv[2]->value.i;
     IDL_ENSURE_SCALAR(argv[3]);
     if (argv[3]->type != IDL_TYP_DOUBLE && argv[3]->type != IDL_TYP_FLOAT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: omega_l must be of type double or float");
     if (argv[3]->type == IDL_TYP_DOUBLE)
          omega_l = argv[3]->value.d;
     else
          omega_l = argv[3]->value.f;
     r = xrtm_set_omega_l_11(d, i_layer, i_deriv, omega_l);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_omega_l_11()");
     return;
}


void IDL_CDECL xrtm_set_omega_l_n1_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     int i_deriv;
     double *omega_l;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_deriv must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_deriv = argv[1]->value.l;
     else
          i_deriv = argv[1]->value.i;
     IDL_ENSURE_ARRAY(argv[2]);
     if (argv[2]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: omega_l must be of type double");
     if (argv[2]->value.arr->n_dim != 1)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: omega_l must be an array with 2 dimensions");
     if (argv[2]->value.arr->dim[0] != (d->n_layers))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: omega_l dimension 1 must have d->n_layers elements");
     omega_l = (double *) argv[2]->value.arr->data;
     r = xrtm_set_omega_l_n1(d, i_deriv, omega_l);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_omega_l_n1()");
     return;
}


void IDL_CDECL xrtm_set_omega_l_1n_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     int i_layer;
     double *omega_l;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_layer must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_layer = argv[1]->value.l;
     else
          i_layer = argv[1]->value.i;
     IDL_ENSURE_ARRAY(argv[2]);
     if (argv[2]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: omega_l must be of type double");
     if (argv[2]->value.arr->n_dim != 1)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: omega_l must be an array with 2 dimensions");
     if (argv[2]->value.arr->dim[0] != (d->n_derivs))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: omega_l dimension 1 must have d->n_derivs elements");
     omega_l = (double *) argv[2]->value.arr->data;
     r = xrtm_set_omega_l_1n(d, i_layer, omega_l);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_omega_l_1n()");
     return;
}


void IDL_CDECL xrtm_set_omega_l_nn_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     size_t dim[16];
     xrtm_data *d;
     double **omega_l;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_ARRAY(argv[1]);
     if (argv[1]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: omega_l must be of type double");
     if (argv[1]->value.arr->n_dim != 2)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: omega_l must be an array with 2 dimensions");
     if (argv[1]->value.arr->dim[1] != (d->n_layers))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: omega_l dimension 2 must have d->n_layers elements");
     if (argv[1]->value.arr->dim[0] != (d->n_derivs))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: omega_l dimension 1 must have d->n_derivs elements");
     dim[0] = d->n_layers;
     dim[1] = d->n_derivs;
     omega_l = (double **) array_from_mem((void *) argv[1]->value.arr->data, 2, dim, sizeof(double), 1);
     r = xrtm_set_omega_l_nn(d, omega_l);
     free_array((void *) omega_l, 2);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_omega_l_nn()");
     return;
}


void IDL_CDECL xrtm_get_omega_l_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     double r;
     xrtm_data *d;
     IDL_VARIABLE var;
     int i_layer;
     int i_deriv;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_layer must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_layer = argv[1]->value.l;
     else
          i_layer = argv[1]->value.i;
     IDL_ENSURE_SCALAR(argv[2]);
     if (argv[2]->type != IDL_TYP_LONG && argv[2]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_deriv must be of type long or int");
     if (argv[2]->type == IDL_TYP_LONG)
          i_deriv = argv[2]->value.l;
     else
          i_deriv = argv[2]->value.i;
     r = xrtm_get_omega_l(d, i_layer, i_deriv);
     if (r == XRTM_DBL_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_omega_l()");
     var.type = IDL_TYP_DOUBLE;
     var.flags = 0;
     var.value.d = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_omega_l()");
     IDL_VarCopy((IDL_VPTR) &var, argv[3]);
     return;
}


void IDL_CDECL xrtm_set_ltau_1_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     int i_layer;
     double ltau;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_layer must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_layer = argv[1]->value.l;
     else
          i_layer = argv[1]->value.i;
     IDL_ENSURE_SCALAR(argv[2]);
     if (argv[2]->type != IDL_TYP_DOUBLE && argv[2]->type != IDL_TYP_FLOAT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: ltau must be of type double or float");
     if (argv[2]->type == IDL_TYP_DOUBLE)
          ltau = argv[2]->value.d;
     else
          ltau = argv[2]->value.f;
     r = xrtm_set_ltau_1(d, i_layer, ltau);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_ltau_1()");
     return;
}


void IDL_CDECL xrtm_set_ltau_n_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     double *ltau;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_ARRAY(argv[1]);
     if (argv[1]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: ltau must be of type double");
     if (argv[1]->value.arr->n_dim != 1)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: ltau must be an array with 2 dimensions");
     if (argv[1]->value.arr->dim[0] != (d->n_layers))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: ltau dimension 1 must have d->n_layers elements");
     ltau = (double *) argv[1]->value.arr->data;
     r = xrtm_set_ltau_n(d, ltau);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_ltau_n()");
     return;
}


void IDL_CDECL xrtm_get_ltau_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     double r;
     xrtm_data *d;
     IDL_VARIABLE var;
     int i_layer;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_layer must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_layer = argv[1]->value.l;
     else
          i_layer = argv[1]->value.i;
     r = xrtm_get_ltau(d, i_layer);
     if (r == XRTM_DBL_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_ltau()");
     var.type = IDL_TYP_DOUBLE;
     var.flags = 0;
     var.value.d = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_ltau()");
     IDL_VarCopy((IDL_VPTR) &var, argv[2]);
     return;
}


void IDL_CDECL xrtm_set_ltau_l_11_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     int i_layer;
     int i_deriv;
     double ltau_l;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_layer must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_layer = argv[1]->value.l;
     else
          i_layer = argv[1]->value.i;
     IDL_ENSURE_SCALAR(argv[2]);
     if (argv[2]->type != IDL_TYP_LONG && argv[2]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_deriv must be of type long or int");
     if (argv[2]->type == IDL_TYP_LONG)
          i_deriv = argv[2]->value.l;
     else
          i_deriv = argv[2]->value.i;
     IDL_ENSURE_SCALAR(argv[3]);
     if (argv[3]->type != IDL_TYP_DOUBLE && argv[3]->type != IDL_TYP_FLOAT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: ltau_l must be of type double or float");
     if (argv[3]->type == IDL_TYP_DOUBLE)
          ltau_l = argv[3]->value.d;
     else
          ltau_l = argv[3]->value.f;
     r = xrtm_set_ltau_l_11(d, i_layer, i_deriv, ltau_l);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_ltau_l_11()");
     return;
}


void IDL_CDECL xrtm_set_ltau_l_n1_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     int i_deriv;
     double *ltau_l;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_deriv must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_deriv = argv[1]->value.l;
     else
          i_deriv = argv[1]->value.i;
     IDL_ENSURE_ARRAY(argv[2]);
     if (argv[2]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: ltau_l must be of type double");
     if (argv[2]->value.arr->n_dim != 1)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: ltau_l must be an array with 2 dimensions");
     if (argv[2]->value.arr->dim[0] != (d->n_layers))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: ltau_l dimension 1 must have d->n_layers elements");
     ltau_l = (double *) argv[2]->value.arr->data;
     r = xrtm_set_ltau_l_n1(d, i_deriv, ltau_l);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_ltau_l_n1()");
     return;
}


void IDL_CDECL xrtm_set_ltau_l_1n_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     int i_layer;
     double *ltau_l;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_layer must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_layer = argv[1]->value.l;
     else
          i_layer = argv[1]->value.i;
     IDL_ENSURE_ARRAY(argv[2]);
     if (argv[2]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: ltau_l must be of type double");
     if (argv[2]->value.arr->n_dim != 1)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: ltau_l must be an array with 2 dimensions");
     if (argv[2]->value.arr->dim[0] != (d->n_derivs))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: ltau_l dimension 1 must have d->n_derivs elements");
     ltau_l = (double *) argv[2]->value.arr->data;
     r = xrtm_set_ltau_l_1n(d, i_layer, ltau_l);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_ltau_l_1n()");
     return;
}


void IDL_CDECL xrtm_set_ltau_l_nn_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     size_t dim[16];
     xrtm_data *d;
     double **ltau_l;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_ARRAY(argv[1]);
     if (argv[1]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: ltau_l must be of type double");
     if (argv[1]->value.arr->n_dim != 2)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: ltau_l must be an array with 2 dimensions");
     if (argv[1]->value.arr->dim[1] != (d->n_layers))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: ltau_l dimension 2 must have d->n_layers elements");
     if (argv[1]->value.arr->dim[0] != (d->n_derivs))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: ltau_l dimension 1 must have d->n_derivs elements");
     dim[0] = d->n_layers;
     dim[1] = d->n_derivs;
     ltau_l = (double **) array_from_mem((void *) argv[1]->value.arr->data, 2, dim, sizeof(double), 1);
     r = xrtm_set_ltau_l_nn(d, ltau_l);
     free_array((void *) ltau_l, 2);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_ltau_l_nn()");
     return;
}


void IDL_CDECL xrtm_get_ltau_l_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     double r;
     xrtm_data *d;
     IDL_VARIABLE var;
     int i_layer;
     int i_deriv;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_layer must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_layer = argv[1]->value.l;
     else
          i_layer = argv[1]->value.i;
     IDL_ENSURE_SCALAR(argv[2]);
     if (argv[2]->type != IDL_TYP_LONG && argv[2]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_deriv must be of type long or int");
     if (argv[2]->type == IDL_TYP_LONG)
          i_deriv = argv[2]->value.l;
     else
          i_deriv = argv[2]->value.i;
     r = xrtm_get_ltau_l(d, i_layer, i_deriv);
     if (r == XRTM_DBL_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_ltau_l()");
     var.type = IDL_TYP_DOUBLE;
     var.flags = 0;
     var.value.d = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_ltau_l()");
     IDL_VarCopy((IDL_VPTR) &var, argv[3]);
     return;
}


void IDL_CDECL xrtm_set_kernel_ampfac_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     int i_kernel;
     double ampfac;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_kernel must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_kernel = argv[1]->value.l;
     else
          i_kernel = argv[1]->value.i;
     IDL_ENSURE_SCALAR(argv[2]);
     if (argv[2]->type != IDL_TYP_DOUBLE && argv[2]->type != IDL_TYP_FLOAT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: ampfac must be of type double or float");
     if (argv[2]->type == IDL_TYP_DOUBLE)
          ampfac = argv[2]->value.d;
     else
          ampfac = argv[2]->value.f;
     r = xrtm_set_kernel_ampfac(d, i_kernel, ampfac);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_kernel_ampfac()");
     return;
}


void IDL_CDECL xrtm_get_kernel_ampfac_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     double r;
     xrtm_data *d;
     IDL_VARIABLE var;
     int i_kernel;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_kernel must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_kernel = argv[1]->value.l;
     else
          i_kernel = argv[1]->value.i;
     r = xrtm_get_kernel_ampfac(d, i_kernel);
     if (r == XRTM_DBL_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_kernel_ampfac()");
     var.type = IDL_TYP_DOUBLE;
     var.flags = 0;
     var.value.d = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_kernel_ampfac()");
     IDL_VarCopy((IDL_VPTR) &var, argv[2]);
     return;
}


void IDL_CDECL xrtm_set_kernel_params_1_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     int i_kernel;
     int i_param;
     double param;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_kernel must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_kernel = argv[1]->value.l;
     else
          i_kernel = argv[1]->value.i;
     IDL_ENSURE_SCALAR(argv[2]);
     if (argv[2]->type != IDL_TYP_LONG && argv[2]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_param must be of type long or int");
     if (argv[2]->type == IDL_TYP_LONG)
          i_param = argv[2]->value.l;
     else
          i_param = argv[2]->value.i;
     IDL_ENSURE_SCALAR(argv[3]);
     if (argv[3]->type != IDL_TYP_DOUBLE && argv[3]->type != IDL_TYP_FLOAT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: param must be of type double or float");
     if (argv[3]->type == IDL_TYP_DOUBLE)
          param = argv[3]->value.d;
     else
          param = argv[3]->value.f;
     r = xrtm_set_kernel_params_1(d, i_kernel, i_param, param);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_kernel_params_1()");
     return;
}


void IDL_CDECL xrtm_set_kernel_params_n_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     int i_kernel;
     double *params;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_kernel must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_kernel = argv[1]->value.l;
     else
          i_kernel = argv[1]->value.i;
     IDL_ENSURE_ARRAY(argv[2]);
     if (argv[2]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: params must be of type double");
     if (argv[2]->value.arr->n_dim != 1)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: params must be an array with 2 dimensions");
     if (argv[2]->value.arr->dim[0] != (kernel_n_params((enum xrtm_kernel_type) d->kernels[i_kernel])))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: params dimension 1 must have kernel_n_params((enum xrtm_kernel_type) d->kernels[i_kernel]) elements");
     params = (double *) argv[2]->value.arr->data;
     r = xrtm_set_kernel_params_n(d, i_kernel, params);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_kernel_params_n()");
     return;
}


void IDL_CDECL xrtm_get_kernel_params_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     double r;
     xrtm_data *d;
     IDL_VARIABLE var;
     int i_kernel;
     int i_param;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_kernel must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_kernel = argv[1]->value.l;
     else
          i_kernel = argv[1]->value.i;
     IDL_ENSURE_SCALAR(argv[2]);
     if (argv[2]->type != IDL_TYP_LONG && argv[2]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_param must be of type long or int");
     if (argv[2]->type == IDL_TYP_LONG)
          i_param = argv[2]->value.l;
     else
          i_param = argv[2]->value.i;
     r = xrtm_get_kernel_params(d, i_kernel, i_param);
     if (r == XRTM_DBL_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_kernel_params()");
     var.type = IDL_TYP_DOUBLE;
     var.flags = 0;
     var.value.d = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_kernel_params()");
     IDL_VarCopy((IDL_VPTR) &var, argv[3]);
     return;
}


void IDL_CDECL xrtm_set_kernel_ampfac_l_1_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     int i_kernel;
     int i_deriv;
     double ampfac_l;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_kernel must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_kernel = argv[1]->value.l;
     else
          i_kernel = argv[1]->value.i;
     IDL_ENSURE_SCALAR(argv[2]);
     if (argv[2]->type != IDL_TYP_LONG && argv[2]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_deriv must be of type long or int");
     if (argv[2]->type == IDL_TYP_LONG)
          i_deriv = argv[2]->value.l;
     else
          i_deriv = argv[2]->value.i;
     IDL_ENSURE_SCALAR(argv[3]);
     if (argv[3]->type != IDL_TYP_DOUBLE && argv[3]->type != IDL_TYP_FLOAT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: ampfac_l must be of type double or float");
     if (argv[3]->type == IDL_TYP_DOUBLE)
          ampfac_l = argv[3]->value.d;
     else
          ampfac_l = argv[3]->value.f;
     r = xrtm_set_kernel_ampfac_l_1(d, i_kernel, i_deriv, ampfac_l);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_kernel_ampfac_l_1()");
     return;
}


void IDL_CDECL xrtm_set_kernel_ampfac_l_n_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     int i_kernel;
     double *ampfac_l;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_kernel must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_kernel = argv[1]->value.l;
     else
          i_kernel = argv[1]->value.i;
     IDL_ENSURE_ARRAY(argv[2]);
     if (argv[2]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: ampfac_l must be of type double");
     if (argv[2]->value.arr->n_dim != 1)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: ampfac_l must be an array with 2 dimensions");
     if (argv[2]->value.arr->dim[0] != (d->n_derivs))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: ampfac_l dimension 1 must have d->n_derivs elements");
     ampfac_l = (double *) argv[2]->value.arr->data;
     r = xrtm_set_kernel_ampfac_l_n(d, i_kernel, ampfac_l);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_kernel_ampfac_l_n()");
     return;
}


void IDL_CDECL xrtm_get_kernel_ampfac_l_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     double r;
     xrtm_data *d;
     IDL_VARIABLE var;
     int i_kernel;
     int i_deriv;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_kernel must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_kernel = argv[1]->value.l;
     else
          i_kernel = argv[1]->value.i;
     IDL_ENSURE_SCALAR(argv[2]);
     if (argv[2]->type != IDL_TYP_LONG && argv[2]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_deriv must be of type long or int");
     if (argv[2]->type == IDL_TYP_LONG)
          i_deriv = argv[2]->value.l;
     else
          i_deriv = argv[2]->value.i;
     r = xrtm_get_kernel_ampfac_l(d, i_kernel, i_deriv);
     if (r == XRTM_DBL_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_kernel_ampfac_l()");
     var.type = IDL_TYP_DOUBLE;
     var.flags = 0;
     var.value.d = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_kernel_ampfac_l()");
     IDL_VarCopy((IDL_VPTR) &var, argv[3]);
     return;
}


void IDL_CDECL xrtm_set_kernel_params_l_11_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     int i_kernel;
     int i_deriv;
     int i_param;
     double param_l;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_kernel must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_kernel = argv[1]->value.l;
     else
          i_kernel = argv[1]->value.i;
     IDL_ENSURE_SCALAR(argv[2]);
     if (argv[2]->type != IDL_TYP_LONG && argv[2]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_deriv must be of type long or int");
     if (argv[2]->type == IDL_TYP_LONG)
          i_deriv = argv[2]->value.l;
     else
          i_deriv = argv[2]->value.i;
     IDL_ENSURE_SCALAR(argv[3]);
     if (argv[3]->type != IDL_TYP_LONG && argv[3]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_param must be of type long or int");
     if (argv[3]->type == IDL_TYP_LONG)
          i_param = argv[3]->value.l;
     else
          i_param = argv[3]->value.i;
     IDL_ENSURE_SCALAR(argv[4]);
     if (argv[4]->type != IDL_TYP_DOUBLE && argv[4]->type != IDL_TYP_FLOAT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: param_l must be of type double or float");
     if (argv[4]->type == IDL_TYP_DOUBLE)
          param_l = argv[4]->value.d;
     else
          param_l = argv[4]->value.f;
     r = xrtm_set_kernel_params_l_11(d, i_kernel, i_deriv, i_param, param_l);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_kernel_params_l_11()");
     return;
}


void IDL_CDECL xrtm_set_kernel_params_l_1n_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     int i_kernel;
     int i_deriv;
     double *params_l;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_kernel must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_kernel = argv[1]->value.l;
     else
          i_kernel = argv[1]->value.i;
     IDL_ENSURE_SCALAR(argv[2]);
     if (argv[2]->type != IDL_TYP_LONG && argv[2]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_deriv must be of type long or int");
     if (argv[2]->type == IDL_TYP_LONG)
          i_deriv = argv[2]->value.l;
     else
          i_deriv = argv[2]->value.i;
     IDL_ENSURE_ARRAY(argv[3]);
     if (argv[3]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: params_l must be of type double");
     if (argv[3]->value.arr->n_dim != 1)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: params_l must be an array with 2 dimensions");
     if (argv[3]->value.arr->dim[0] != (kernel_n_params((enum xrtm_kernel_type) d->kernels[i_kernel])))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: params_l dimension 1 must have kernel_n_params((enum xrtm_kernel_type) d->kernels[i_kernel]) elements");
     params_l = (double *) argv[3]->value.arr->data;
     r = xrtm_set_kernel_params_l_1n(d, i_kernel, i_deriv, params_l);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_kernel_params_l_1n()");
     return;
}


void IDL_CDECL xrtm_set_kernel_params_l_n1_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     int i_kernel;
     int i_param;
     double *params_l;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_kernel must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_kernel = argv[1]->value.l;
     else
          i_kernel = argv[1]->value.i;
     IDL_ENSURE_SCALAR(argv[2]);
     if (argv[2]->type != IDL_TYP_LONG && argv[2]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_param must be of type long or int");
     if (argv[2]->type == IDL_TYP_LONG)
          i_param = argv[2]->value.l;
     else
          i_param = argv[2]->value.i;
     IDL_ENSURE_ARRAY(argv[3]);
     if (argv[3]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: params_l must be of type double");
     if (argv[3]->value.arr->n_dim != 1)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: params_l must be an array with 2 dimensions");
     if (argv[3]->value.arr->dim[0] != (d->n_derivs))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: params_l dimension 1 must have d->n_derivs elements");
     params_l = (double *) argv[3]->value.arr->data;
     r = xrtm_set_kernel_params_l_n1(d, i_kernel, i_param, params_l);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_kernel_params_l_n1()");
     return;
}


void IDL_CDECL xrtm_set_kernel_params_l_nn_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     size_t dim[16];
     xrtm_data *d;
     int i_kernel;
     double **params_l;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_kernel must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_kernel = argv[1]->value.l;
     else
          i_kernel = argv[1]->value.i;
     IDL_ENSURE_ARRAY(argv[2]);
     if (argv[2]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: params_l must be of type double");
     if (argv[2]->value.arr->n_dim != 2)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: params_l must be an array with 2 dimensions");
     if (argv[2]->value.arr->dim[1] != (d->n_derivs))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: params_l dimension 2 must have d->n_derivs elements");
     if (argv[2]->value.arr->dim[0] != (kernel_n_params((enum xrtm_kernel_type) d->kernels[i_kernel])))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: params_l dimension 1 must have kernel_n_params((enum xrtm_kernel_type) d->kernels[i_kernel]) elements");
     dim[0] = d->n_derivs;
     dim[1] = kernel_n_params((enum xrtm_kernel_type) d->kernels[i_kernel]);
     params_l = (double **) array_from_mem((void *) argv[2]->value.arr->data, 2, dim, sizeof(double), 1);
     r = xrtm_set_kernel_params_l_nn(d, i_kernel, params_l);
     free_array((void *) params_l, 2);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_set_kernel_params_l_nn()");
     return;
}


void IDL_CDECL xrtm_get_kernel_params_l_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     double r;
     xrtm_data *d;
     IDL_VARIABLE var;
     int i_kernel;
     int i_deriv;
     int i_param;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_LONG && argv[1]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_kernel must be of type long or int");
     if (argv[1]->type == IDL_TYP_LONG)
          i_kernel = argv[1]->value.l;
     else
          i_kernel = argv[1]->value.i;
     IDL_ENSURE_SCALAR(argv[2]);
     if (argv[2]->type != IDL_TYP_LONG && argv[2]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_deriv must be of type long or int");
     if (argv[2]->type == IDL_TYP_LONG)
          i_deriv = argv[2]->value.l;
     else
          i_deriv = argv[2]->value.i;
     IDL_ENSURE_SCALAR(argv[3]);
     if (argv[3]->type != IDL_TYP_LONG && argv[3]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: i_param must be of type long or int");
     if (argv[3]->type == IDL_TYP_LONG)
          i_param = argv[3]->value.l;
     else
          i_param = argv[3]->value.i;
     r = xrtm_get_kernel_params_l(d, i_kernel, i_deriv, i_param);
     if (r == XRTM_DBL_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_kernel_params_l()");
     var.type = IDL_TYP_DOUBLE;
     var.flags = 0;
     var.value.d = r;
     if (var.value.d == XRTM_DBL_ERROR)
     IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_get_kernel_params_l()");
     IDL_VarCopy((IDL_VPTR) &var, argv[4]);
     return;
}


void IDL_CDECL xrtm_update_varied_layers_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     r = xrtm_update_varied_layers(d);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_update_varied_layers()");
     return;
}


void IDL_CDECL xrtm_qx_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     IDL_VPTR ptr;
     IDL_MEMINT dim_idl[16];
     double *qx;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     qx = malloc((d->n_quad) * sizeof(double));
     r = xrtm_qx(d, qx);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_qx()");
     dim_idl[0] = d->n_quad;
     ptr = IDL_ImportArray(1, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) qx, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[1]);
     return;
}


void IDL_CDECL xrtm_qw_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     IDL_VPTR ptr;
     IDL_MEMINT dim_idl[16];
     double *qw;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     qw = malloc((d->n_quad) * sizeof(double));
     r = xrtm_qw(d, qw);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_qw()");
     dim_idl[0] = d->n_quad;
     ptr = IDL_ImportArray(1, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) qw, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[1]);
     return;
}


void IDL_CDECL xrtm_kernel_qx_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     IDL_VPTR ptr;
     IDL_MEMINT dim_idl[16];
     double *kernel_qx;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     kernel_qx = malloc((d->n_kernel_quad) * sizeof(double));
     r = xrtm_kernel_qx(d, kernel_qx);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_kernel_qx()");
     dim_idl[0] = d->n_kernel_quad;
     ptr = IDL_ImportArray(1, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) kernel_qx, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[1]);
     return;
}


void IDL_CDECL xrtm_kernel_qw_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     xrtm_data *d;
     IDL_VPTR ptr;
     IDL_MEMINT dim_idl[16];
     double *kernel_qw;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     kernel_qw = malloc((d->n_kernel_quad) * sizeof(double));
     r = xrtm_kernel_qw(d, kernel_qw);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_kernel_qw()");
     dim_idl[0] = d->n_kernel_quad;
     ptr = IDL_ImportArray(1, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) kernel_qw, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[1]);
     return;
}


void IDL_CDECL xrtm_solution_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     size_t dim[16];
     xrtm_data *d;
     IDL_VPTR ptr;
     IDL_MEMINT dim_idl[16];
     enum xrtm_solver_mask solver;
     int solutions;
     int n_out_phis;
     double **out_phis;
     double ****I_p;
     void *I_p_data;
     double ****I_m;
     void *I_m_data;
     double *****K_p;
     void *K_p_data;
     double *****K_m;
     void *K_m_data;
     double *mean_p;
     double *mean_m;
     double **mean_p_l;
     void *mean_p_l_data;
     double **mean_m_l;
     void *mean_m_l_data;
     double *flux_p;
     double *flux_m;
     double **flux_p_l;
     void *flux_p_l_data;
     double **flux_m_l;
     void *flux_m_l_data;
     double *flux_div;
     double **flux_div_l;
     void *flux_div_l_data;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_STRING)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: solver must be of type string");
     if ((r = xrtm_solver_name_to_mask(IDL_STRING_STR(&argv[1]->value.str))) < 0)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_solver_name_to_mask()");
     solver = r;
     IDL_ENSURE_SCALAR(argv[2]);
     if (argv[2]->type != IDL_TYP_LONG && argv[2]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: solutions must be of type long or int");
     if (argv[2]->type == IDL_TYP_LONG)
          solutions = argv[2]->value.l;
     else
          solutions = argv[2]->value.i;
     IDL_ENSURE_SCALAR(argv[3]);
     if (argv[3]->type != IDL_TYP_LONG && argv[3]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: n_out_phis must be of type long or int");
     if (argv[3]->type == IDL_TYP_LONG)
          n_out_phis = argv[3]->value.l;
     else
          n_out_phis = argv[3]->value.i;
     IDL_ENSURE_ARRAY(argv[4]);
     if (argv[4]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: out_phis must be of type double");
     if (argv[4]->value.arr->n_dim != 2)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: out_phis must be an array with 2 dimensions");
     if (argv[4]->value.arr->dim[1] != (d->n_umus))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: out_phis dimension 2 must have d->n_umus elements");
     if (argv[4]->value.arr->dim[0] != (n_out_phis))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: out_phis dimension 1 must have n_out_phis elements");
     dim[0] = d->n_umus;
     dim[1] = n_out_phis;
     out_phis = (double **) array_from_mem((void *) argv[4]->value.arr->data, 2, dim, sizeof(double), 1);
     I_p_data = malloc((d->n_ulevels) * (d->n_umus == 0 ? d->n_quad : d->n_umus) * (n_out_phis) * (d->n_stokes) * sizeof(double));
     dim[0] = d->n_ulevels;
     dim[1] = d->n_umus == 0 ? d->n_quad : d->n_umus;
     dim[2] = n_out_phis;
     dim[3] = d->n_stokes;
     I_p = (double ****) array_from_mem(I_p_data, 4, dim, sizeof(double), 1);
     I_m_data = malloc((d->n_ulevels) * (d->n_umus == 0 ? d->n_quad : d->n_umus) * (n_out_phis) * (d->n_stokes) * sizeof(double));
     dim[0] = d->n_ulevels;
     dim[1] = d->n_umus == 0 ? d->n_quad : d->n_umus;
     dim[2] = n_out_phis;
     dim[3] = d->n_stokes;
     I_m = (double ****) array_from_mem(I_m_data, 4, dim, sizeof(double), 1);
     K_p_data = malloc((d->n_ulevels) * (d->n_derivs) * (d->n_umus == 0 ? d->n_quad : d->n_umus) * (n_out_phis) * (d->n_stokes) * sizeof(double));
     dim[0] = d->n_ulevels;
     dim[1] = d->n_derivs;
     dim[2] = d->n_umus == 0 ? d->n_quad : d->n_umus;
     dim[3] = n_out_phis;
     dim[4] = d->n_stokes;
     K_p = (double *****) array_from_mem(K_p_data, 5, dim, sizeof(double), 1);
     K_m_data = malloc((d->n_ulevels) * (d->n_derivs) * (d->n_umus == 0 ? d->n_quad : d->n_umus) * (n_out_phis) * (d->n_stokes) * sizeof(double));
     dim[0] = d->n_ulevels;
     dim[1] = d->n_derivs;
     dim[2] = d->n_umus == 0 ? d->n_quad : d->n_umus;
     dim[3] = n_out_phis;
     dim[4] = d->n_stokes;
     K_m = (double *****) array_from_mem(K_m_data, 5, dim, sizeof(double), 1);
     mean_p = malloc((d->n_ulevels) * sizeof(double));
     mean_m = malloc((d->n_ulevels) * sizeof(double));
     mean_p_l_data = malloc((d->n_ulevels) * (d->n_derivs) * sizeof(double));
     dim[0] = d->n_ulevels;
     dim[1] = d->n_derivs;
     mean_p_l = (double **) array_from_mem(mean_p_l_data, 2, dim, sizeof(double), 1);
     mean_m_l_data = malloc((d->n_ulevels) * (d->n_derivs) * sizeof(double));
     dim[0] = d->n_ulevels;
     dim[1] = d->n_derivs;
     mean_m_l = (double **) array_from_mem(mean_m_l_data, 2, dim, sizeof(double), 1);
     flux_p = malloc((d->n_ulevels) * sizeof(double));
     flux_m = malloc((d->n_ulevels) * sizeof(double));
     flux_p_l_data = malloc((d->n_ulevels) * (d->n_derivs) * sizeof(double));
     dim[0] = d->n_ulevels;
     dim[1] = d->n_derivs;
     flux_p_l = (double **) array_from_mem(flux_p_l_data, 2, dim, sizeof(double), 1);
     flux_m_l_data = malloc((d->n_ulevels) * (d->n_derivs) * sizeof(double));
     dim[0] = d->n_ulevels;
     dim[1] = d->n_derivs;
     flux_m_l = (double **) array_from_mem(flux_m_l_data, 2, dim, sizeof(double), 1);
     flux_div = malloc((d->n_ulevels) * sizeof(double));
     flux_div_l_data = malloc((d->n_ulevels) * (d->n_derivs) * sizeof(double));
     dim[0] = d->n_ulevels;
     dim[1] = d->n_derivs;
     flux_div_l = (double **) array_from_mem(flux_div_l_data, 2, dim, sizeof(double), 1);
     r = xrtm_solution(d, (enum xrtm_solver_mask) solver, solutions, n_out_phis, out_phis, I_p, I_m, K_p, K_m, mean_p, mean_m, mean_p_l, mean_m_l, flux_p, flux_m, flux_p_l, flux_m_l, flux_div, flux_div_l);
     free_array((void *) out_phis, 2);
     free_array((void *) I_p, 4);
     free_array((void *) I_m, 4);
     free_array((void *) K_p, 5);
     free_array((void *) K_m, 5);
     free_array((void *) mean_p_l, 2);
     free_array((void *) mean_m_l, 2);
     free_array((void *) flux_p_l, 2);
     free_array((void *) flux_m_l, 2);
     free_array((void *) flux_div_l, 2);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_solution()");
     dim_idl[3] = d->n_ulevels;
     dim_idl[2] = d->n_umus == 0 ? d->n_quad : d->n_umus;
     dim_idl[1] = n_out_phis;
     dim_idl[0] = d->n_stokes;
     ptr = IDL_ImportArray(4, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) I_p_data, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[5]);
     dim_idl[3] = d->n_ulevels;
     dim_idl[2] = d->n_umus == 0 ? d->n_quad : d->n_umus;
     dim_idl[1] = n_out_phis;
     dim_idl[0] = d->n_stokes;
     ptr = IDL_ImportArray(4, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) I_m_data, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[6]);
     dim_idl[4] = d->n_ulevels;
     dim_idl[3] = d->n_derivs;
     dim_idl[2] = d->n_umus == 0 ? d->n_quad : d->n_umus;
     dim_idl[1] = n_out_phis;
     dim_idl[0] = d->n_stokes;
     ptr = IDL_ImportArray(5, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) K_p_data, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[7]);
     dim_idl[4] = d->n_ulevels;
     dim_idl[3] = d->n_derivs;
     dim_idl[2] = d->n_umus == 0 ? d->n_quad : d->n_umus;
     dim_idl[1] = n_out_phis;
     dim_idl[0] = d->n_stokes;
     ptr = IDL_ImportArray(5, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) K_m_data, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[8]);
     dim_idl[0] = d->n_ulevels;
     ptr = IDL_ImportArray(1, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) mean_p, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[9]);
     dim_idl[0] = d->n_ulevels;
     ptr = IDL_ImportArray(1, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) mean_m, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[10]);
     dim_idl[1] = d->n_ulevels;
     dim_idl[0] = d->n_derivs;
     ptr = IDL_ImportArray(2, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) mean_p_l_data, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[11]);
     dim_idl[1] = d->n_ulevels;
     dim_idl[0] = d->n_derivs;
     ptr = IDL_ImportArray(2, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) mean_m_l_data, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[12]);
     dim_idl[0] = d->n_ulevels;
     ptr = IDL_ImportArray(1, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) flux_p, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[13]);
     dim_idl[0] = d->n_ulevels;
     ptr = IDL_ImportArray(1, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) flux_m, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[14]);
     dim_idl[1] = d->n_ulevels;
     dim_idl[0] = d->n_derivs;
     ptr = IDL_ImportArray(2, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) flux_p_l_data, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[15]);
     dim_idl[1] = d->n_ulevels;
     dim_idl[0] = d->n_derivs;
     ptr = IDL_ImportArray(2, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) flux_m_l_data, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[16]);
     dim_idl[0] = d->n_ulevels;
     ptr = IDL_ImportArray(1, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) flux_div, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[17]);
     dim_idl[1] = d->n_ulevels;
     dim_idl[0] = d->n_derivs;
     ptr = IDL_ImportArray(2, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) flux_div_l_data, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[18]);
     return;
}


void IDL_CDECL xrtm_radiance_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     size_t dim[16];
     xrtm_data *d;
     IDL_VPTR ptr;
     IDL_MEMINT dim_idl[16];
     enum xrtm_solver_mask solver;
     int n_out_phis;
     double **out_phis;
     double ****I_p;
     void *I_p_data;
     double ****I_m;
     void *I_m_data;
     double *****K_p;
     void *K_p_data;
     double *****K_m;
     void *K_m_data;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_STRING)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: solver must be of type string");
     if ((r = xrtm_solver_name_to_mask(IDL_STRING_STR(&argv[1]->value.str))) < 0)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_solver_name_to_mask()");
     solver = r;
     IDL_ENSURE_SCALAR(argv[2]);
     if (argv[2]->type != IDL_TYP_LONG && argv[2]->type != IDL_TYP_INT)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: n_out_phis must be of type long or int");
     if (argv[2]->type == IDL_TYP_LONG)
          n_out_phis = argv[2]->value.l;
     else
          n_out_phis = argv[2]->value.i;
     IDL_ENSURE_ARRAY(argv[3]);
     if (argv[3]->type != IDL_TYP_DOUBLE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: out_phis must be of type double");
     if (argv[3]->value.arr->n_dim != 2)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: out_phis must be an array with 2 dimensions");
     if (argv[3]->value.arr->dim[1] != (d->n_umus))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: out_phis dimension 2 must have d->n_umus elements");
     if (argv[3]->value.arr->dim[0] != (n_out_phis))
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: out_phis dimension 1 must have n_out_phis elements");
     dim[0] = d->n_umus;
     dim[1] = n_out_phis;
     out_phis = (double **) array_from_mem((void *) argv[3]->value.arr->data, 2, dim, sizeof(double), 1);
     I_p_data = malloc((d->n_ulevels) * (d->n_umus == 0 ? d->n_quad : d->n_umus) * (n_out_phis) * (d->n_stokes) * sizeof(double));
     dim[0] = d->n_ulevels;
     dim[1] = d->n_umus == 0 ? d->n_quad : d->n_umus;
     dim[2] = n_out_phis;
     dim[3] = d->n_stokes;
     I_p = (double ****) array_from_mem(I_p_data, 4, dim, sizeof(double), 1);
     I_m_data = malloc((d->n_ulevels) * (d->n_umus == 0 ? d->n_quad : d->n_umus) * (n_out_phis) * (d->n_stokes) * sizeof(double));
     dim[0] = d->n_ulevels;
     dim[1] = d->n_umus == 0 ? d->n_quad : d->n_umus;
     dim[2] = n_out_phis;
     dim[3] = d->n_stokes;
     I_m = (double ****) array_from_mem(I_m_data, 4, dim, sizeof(double), 1);
     K_p_data = malloc((d->n_ulevels) * (d->n_derivs) * (d->n_umus == 0 ? d->n_quad : d->n_umus) * (n_out_phis) * (d->n_stokes) * sizeof(double));
     dim[0] = d->n_ulevels;
     dim[1] = d->n_derivs;
     dim[2] = d->n_umus == 0 ? d->n_quad : d->n_umus;
     dim[3] = n_out_phis;
     dim[4] = d->n_stokes;
     K_p = (double *****) array_from_mem(K_p_data, 5, dim, sizeof(double), 1);
     K_m_data = malloc((d->n_ulevels) * (d->n_derivs) * (d->n_umus == 0 ? d->n_quad : d->n_umus) * (n_out_phis) * (d->n_stokes) * sizeof(double));
     dim[0] = d->n_ulevels;
     dim[1] = d->n_derivs;
     dim[2] = d->n_umus == 0 ? d->n_quad : d->n_umus;
     dim[3] = n_out_phis;
     dim[4] = d->n_stokes;
     K_m = (double *****) array_from_mem(K_m_data, 5, dim, sizeof(double), 1);
     r = xrtm_radiance(d, (enum xrtm_solver_mask) solver, n_out_phis, out_phis, I_p, I_m, K_p, K_m);
     free_array((void *) out_phis, 2);
     free_array((void *) I_p, 4);
     free_array((void *) I_m, 4);
     free_array((void *) K_p, 5);
     free_array((void *) K_m, 5);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_radiance()");
     dim_idl[3] = d->n_ulevels;
     dim_idl[2] = d->n_umus == 0 ? d->n_quad : d->n_umus;
     dim_idl[1] = n_out_phis;
     dim_idl[0] = d->n_stokes;
     ptr = IDL_ImportArray(4, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) I_p_data, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[4]);
     dim_idl[3] = d->n_ulevels;
     dim_idl[2] = d->n_umus == 0 ? d->n_quad : d->n_umus;
     dim_idl[1] = n_out_phis;
     dim_idl[0] = d->n_stokes;
     ptr = IDL_ImportArray(4, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) I_m_data, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[5]);
     dim_idl[4] = d->n_ulevels;
     dim_idl[3] = d->n_derivs;
     dim_idl[2] = d->n_umus == 0 ? d->n_quad : d->n_umus;
     dim_idl[1] = n_out_phis;
     dim_idl[0] = d->n_stokes;
     ptr = IDL_ImportArray(5, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) K_p_data, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[6]);
     dim_idl[4] = d->n_ulevels;
     dim_idl[3] = d->n_derivs;
     dim_idl[2] = d->n_umus == 0 ? d->n_quad : d->n_umus;
     dim_idl[1] = n_out_phis;
     dim_idl[0] = d->n_stokes;
     ptr = IDL_ImportArray(5, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) K_m_data, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[7]);
     return;
}


void IDL_CDECL xrtm_mean_radiance_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     size_t dim[16];
     xrtm_data *d;
     IDL_VPTR ptr;
     IDL_MEMINT dim_idl[16];
     enum xrtm_solver_mask solver;
     double *mean_p;
     double *mean_m;
     double **mean_p_l;
     void *mean_p_l_data;
     double **mean_m_l;
     void *mean_m_l_data;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_STRING)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: solver must be of type string");
     if ((r = xrtm_solver_name_to_mask(IDL_STRING_STR(&argv[1]->value.str))) < 0)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_solver_name_to_mask()");
     solver = r;
     mean_p = malloc((d->n_ulevels) * sizeof(double));
     mean_m = malloc((d->n_ulevels) * sizeof(double));
     mean_p_l_data = malloc((d->n_ulevels) * (d->n_derivs) * sizeof(double));
     dim[0] = d->n_ulevels;
     dim[1] = d->n_derivs;
     mean_p_l = (double **) array_from_mem(mean_p_l_data, 2, dim, sizeof(double), 1);
     mean_m_l_data = malloc((d->n_ulevels) * (d->n_derivs) * sizeof(double));
     dim[0] = d->n_ulevels;
     dim[1] = d->n_derivs;
     mean_m_l = (double **) array_from_mem(mean_m_l_data, 2, dim, sizeof(double), 1);
     r = xrtm_mean_radiance(d, (enum xrtm_solver_mask) solver, mean_p, mean_m, mean_p_l, mean_m_l);
     free_array((void *) mean_p_l, 2);
     free_array((void *) mean_m_l, 2);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_mean_radiance()");
     dim_idl[0] = d->n_ulevels;
     ptr = IDL_ImportArray(1, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) mean_p, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[2]);
     dim_idl[0] = d->n_ulevels;
     ptr = IDL_ImportArray(1, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) mean_m, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[3]);
     dim_idl[1] = d->n_ulevels;
     dim_idl[0] = d->n_derivs;
     ptr = IDL_ImportArray(2, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) mean_p_l_data, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[4]);
     dim_idl[1] = d->n_ulevels;
     dim_idl[0] = d->n_derivs;
     ptr = IDL_ImportArray(2, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) mean_m_l_data, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[5]);
     return;
}


void IDL_CDECL xrtm_flux_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     size_t dim[16];
     xrtm_data *d;
     IDL_VPTR ptr;
     IDL_MEMINT dim_idl[16];
     enum xrtm_solver_mask solver;
     double *flux_p;
     double *flux_m;
     double **flux_p_l;
     void *flux_p_l_data;
     double **flux_m_l;
     void *flux_m_l_data;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_STRING)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: solver must be of type string");
     if ((r = xrtm_solver_name_to_mask(IDL_STRING_STR(&argv[1]->value.str))) < 0)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_solver_name_to_mask()");
     solver = r;
     flux_p = malloc((d->n_ulevels) * sizeof(double));
     flux_m = malloc((d->n_ulevels) * sizeof(double));
     flux_p_l_data = malloc((d->n_ulevels) * (d->n_derivs) * sizeof(double));
     dim[0] = d->n_ulevels;
     dim[1] = d->n_derivs;
     flux_p_l = (double **) array_from_mem(flux_p_l_data, 2, dim, sizeof(double), 1);
     flux_m_l_data = malloc((d->n_ulevels) * (d->n_derivs) * sizeof(double));
     dim[0] = d->n_ulevels;
     dim[1] = d->n_derivs;
     flux_m_l = (double **) array_from_mem(flux_m_l_data, 2, dim, sizeof(double), 1);
     r = xrtm_flux(d, (enum xrtm_solver_mask) solver, flux_p, flux_m, flux_p_l, flux_m_l);
     free_array((void *) flux_p_l, 2);
     free_array((void *) flux_m_l, 2);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_flux()");
     dim_idl[0] = d->n_ulevels;
     ptr = IDL_ImportArray(1, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) flux_p, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[2]);
     dim_idl[0] = d->n_ulevels;
     ptr = IDL_ImportArray(1, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) flux_m, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[3]);
     dim_idl[1] = d->n_ulevels;
     dim_idl[0] = d->n_derivs;
     ptr = IDL_ImportArray(2, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) flux_p_l_data, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[4]);
     dim_idl[1] = d->n_ulevels;
     dim_idl[0] = d->n_derivs;
     ptr = IDL_ImportArray(2, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) flux_m_l_data, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[5]);
     return;
}


void IDL_CDECL xrtm_flux_divergence_dlm(int argc, IDL_VPTR argv[], char *argk)
{
     int r;
     size_t dim[16];
     xrtm_data *d;
     IDL_VPTR ptr;
     IDL_MEMINT dim_idl[16];
     enum xrtm_solver_mask solver;
     double *flux_div;
     double **flux_div_l;
     void *flux_div_l_data;
     IDL_ENSURE_ARRAY(argv[0]);
     if (argv[0]->type != IDL_TYP_BYTE)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: Invalid xrtm instance");
     d = (xrtm_data *) argv[0]->value.arr->data;
     IDL_ENSURE_SCALAR(argv[1]);
     if (argv[1]->type != IDL_TYP_STRING)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: solver must be of type string");
     if ((r = xrtm_solver_name_to_mask(IDL_STRING_STR(&argv[1]->value.str))) < 0)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_solver_name_to_mask()");
     solver = r;
     flux_div = malloc((d->n_ulevels) * sizeof(double));
     flux_div_l_data = malloc((d->n_ulevels) * (d->n_derivs) * sizeof(double));
     dim[0] = d->n_ulevels;
     dim[1] = d->n_derivs;
     flux_div_l = (double **) array_from_mem(flux_div_l_data, 2, dim, sizeof(double), 1);
     r = xrtm_flux_divergence(d, (enum xrtm_solver_mask) solver, flux_div, flux_div_l);
     free_array((void *) flux_div_l, 2);
     if (r == XRTM_INT_ERROR)
          IDL_Message(IDL_M_NAMED_GENERIC, IDL_MSG_LONGJMP, "ERROR: xrtm_flux_divergence()");
     dim_idl[0] = d->n_ulevels;
     ptr = IDL_ImportArray(1, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) flux_div, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[2]);
     dim_idl[1] = d->n_ulevels;
     dim_idl[0] = d->n_derivs;
     ptr = IDL_ImportArray(2, (IDL_MEMINT *) dim_idl, IDL_TYP_DOUBLE, (UCHAR *) flux_div_l_data, 0, NULL);
     IDL_VarCopy((IDL_VPTR) ptr, argv[3]);
     return;
}


