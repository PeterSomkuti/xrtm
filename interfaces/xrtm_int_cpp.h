/*******************************************************************************
 * This file was generated by bindx version 0.01.  Edit at your own risk.
 ******************************************************************************/

#ifndef XRTM_INT_CPP_H
#define XRTM_INT_CPP_H

#include <gutil.h>

#include <xrtm_interface.h>


class xrtm_int_cpp
{
private:
     xrtm_data d;


public:
     enum xrtm_errors { ERROR };

     enum option_mask {
          OPTION_CALC_DERIVS = XRTM_OPTION_CALC_DERIVS,
          OPTION_REVERSE_DERIVS = XRTM_OPTION_REVERSE_DERIVS,
          OPTION_DELTA_M = XRTM_OPTION_DELTA_M,
          OPTION_N_T_TMS = XRTM_OPTION_N_T_TMS,
          OPTION_FOUR_CONV_OLD = XRTM_OPTION_FOUR_CONV_OLD,
          OPTION_FOUR_CONV_NEW = XRTM_OPTION_FOUR_CONV_NEW,
          OPTION_NO_AZIMUTHAL = XRTM_OPTION_NO_AZIMUTHAL,
          OPTION_OUTPUT_AT_LEVELS = XRTM_OPTION_OUTPUT_AT_LEVELS,
          OPTION_OUTPUT_AT_TAUS = XRTM_OPTION_OUTPUT_AT_TAUS,
          OPTION_PART_SOL_CLASSICAL = XRTM_OPTION_PART_SOL_CLASSICAL,
          OPTION_PART_SOL_GREENS = XRTM_OPTION_PART_SOL_GREENS,
          OPTION_PHASE_SCALAR = XRTM_OPTION_PHASE_SCALAR,
          OPTION_PHASE_MATRIX_GC = XRTM_OPTION_PHASE_MATRIX_GC,
          OPTION_PHASE_MATRIX_LC = XRTM_OPTION_PHASE_MATRIX_LC,
          OPTION_PSA = XRTM_OPTION_PSA,
          OPTION_QUAD_NORM_GAUS_LEG = XRTM_OPTION_QUAD_NORM_GAUS_LEG,
          OPTION_QUAD_DOUB_GAUS_LEG = XRTM_OPTION_QUAD_DOUB_GAUS_LEG,
          OPTION_QUAD_LOBATTO = XRTM_OPTION_QUAD_LOBATTO,
          OPTION_SAVE_LEG_POLYS = XRTM_OPTION_SAVE_LEG_POLYS,
          OPTION_SAVE_PHASE_MATS = XRTM_OPTION_SAVE_PHASE_MATS,
          OPTION_SAVE_LOCAL_R_T = XRTM_OPTION_SAVE_LOCAL_R_T,
          OPTION_SAVE_LAYER_R_T_S = XRTM_OPTION_SAVE_LAYER_R_T_S,
          OPTION_SAVE_TOTAL_R_T_S = XRTM_OPTION_SAVE_TOTAL_R_T_S,
          OPTION_SFI = XRTM_OPTION_SFI,
          OPTION_SOURCE_SOLAR = XRTM_OPTION_SOURCE_SOLAR,
          OPTION_SOURCE_THERMAL = XRTM_OPTION_SOURCE_THERMAL,
          OPTION_STACK_REUSE_ADDING = XRTM_OPTION_STACK_REUSE_ADDING,
          OPTION_TOP_DOWN_ADDING = XRTM_OPTION_TOP_DOWN_ADDING,
          OPTION_BOTTOM_UP_ADDING = XRTM_OPTION_BOTTOM_UP_ADDING,
          OPTION_UPWELLING_OUTPUT = XRTM_OPTION_UPWELLING_OUTPUT,
          OPTION_DOWNWELLING_OUTPUT = XRTM_OPTION_DOWNWELLING_OUTPUT,
          OPTION_VECTOR = XRTM_OPTION_VECTOR
     };

     enum solver_mask {
          SOLVER_DOUB_ADD = XRTM_SOLVER_DOUB_ADD,
          SOLVER_EIG_ADD = XRTM_SOLVER_EIG_ADD,
          SOLVER_EIG_BVP = XRTM_SOLVER_EIG_BVP,
          SOLVER_FOUR_STREAM = XRTM_SOLVER_FOUR_STREAM,
          SOLVER_MEM_BVP = XRTM_SOLVER_MEM_BVP,
          SOLVER_PADE_ADD = XRTM_SOLVER_PADE_ADD,
          SOLVER_SINGLE = XRTM_SOLVER_SINGLE,
          SOLVER_SIX_STREAM = XRTM_SOLVER_SIX_STREAM,
          SOLVER_SOS = XRTM_SOLVER_SOS,
          SOLVER_TWO_OS = XRTM_SOLVER_TWO_OS,
          SOLVER_TWO_STREAM = XRTM_SOLVER_TWO_STREAM
     };

     enum output_mask {
          OUTPUT_RADIANCE = XRTM_OUTPUT_RADIANCE,
          OUTPUT_RADIANCE_MEAN = XRTM_OUTPUT_RADIANCE_MEAN,
          OUTPUT_FLUX = XRTM_OUTPUT_FLUX,
          OUTPUT_FLUX_DIVERGENCE = XRTM_OUTPUT_FLUX_DIVERGENCE
     };

     enum kernel_type {
          KERNEL_LAMBERTIAN = XRTM_KERNEL_LAMBERTIAN,
          KERNEL_DIRECT_AND_DIFFUSE = XRTM_KERNEL_DIRECT_AND_DIFFUSE,
          KERNEL_ROUJEAN = XRTM_KERNEL_ROUJEAN,
          KERNEL_LI_SPARSE = XRTM_KERNEL_LI_SPARSE,
          KERNEL_LI_DENSE = XRTM_KERNEL_LI_DENSE,
          KERNEL_ROSS_THIN = XRTM_KERNEL_ROSS_THIN,
          KERNEL_ROSS_THICK = XRTM_KERNEL_ROSS_THICK,
          KERNEL_HAPKE = XRTM_KERNEL_HAPKE,
          KERNEL_RAHMAN = XRTM_KERNEL_RAHMAN,
          KERNEL_COX_MUNK = XRTM_KERNEL_COX_MUNK,
          KERNEL_USER_DEFINED = XRTM_KERNEL_USER_DEFINED
     };


     xrtm_int_cpp(int options, int solvers, int max_coef, int n_quad, int n_stokes, int n_derivs, int n_layers, int n_theta_0s, int n_kernels, int n_kernel_quad, kernel_type *kernels, int n_out_levels, int n_out_thetas);
     ~xrtm_int_cpp();
     int get_options();
     int get_solvers();
     int get_max_coef();
     int get_n_quad();
     int get_n_stokes();
     int get_n_derivs();
     int get_n_layers();
     int get_n_kernels();
     int get_n_kernel_quad();
     int get_kernel(int i_kernel);
     int get_n_out_levels();
     int get_n_out_thetas();
     void set_doub_d_tau(double d_tau);
     double get_doub_d_tau();
     void set_pade_params(int pade_s, int pade_r);
     void get_pade_params(int *pade_s, int *pade_r);
     void set_sos_params(int max_os, double max_tau, double sos_tol);
     void get_sos_params(int *max_os, double *max_tau, double *sos_tol);
     void set_fourier_tol(double fourier_tol);
     double get_fourier_tol();
     void set_lambda(double lambda);
     double get_lambda();
     void set_planet_r(double planet_r);
     double get_planet_r();
     void set_levels_z(double *levels_z);
     void get_levels_z(double *levels_z);
     void set_out_levels(int *out_levels);
     void get_out_levels(int *out_levels);
     void set_out_taus(double *out_taus);
     void get_out_taus(double *out_taus);
     void set_out_thetas(double *out_thetas);
     void get_out_thetas(double *out_thetas);
     void set_F_iso_top(double F_iso_top);
     double get_F_iso_top();
     void set_F_iso_top_l_1(int i_deriv, double F_iso_top_l);
     void set_F_iso_top_l_n(double *F_iso_top_l);
     double get_F_iso_top_l(int i_deriv);
     void set_F_iso_bot(double F_iso_bot);
     double get_F_iso_bot();
     void set_F_iso_bot_l_1(int i_deriv, double F_iso_bot_l);
     void set_F_iso_bot_l_n(double *F_iso_bot_l);
     double get_F_iso_bot_l(int i_deriv);
     void set_F_0(double F_0);
     double get_F_0();
     void set_theta_0(double theta_0);
     double get_theta_0();
     void set_phi_0(double phi_0);
     double get_phi_0();
     void set_levels_b(double *levels_b);
     void get_levels_b(double *levels_b);
     void set_levels_b_l_1(int i_deriv, double *levels_b_l);
     void set_levels_b_l_n(double **levels_b_l);
     void get_levels_b_l(int i_deriv, double *levels_b_l);
     void set_surface_b(double surface_b);
     double get_surface_b();
     void set_surface_b_l_1(int i_deriv, double surface_b_l);
     void set_surface_b_l_n(double *surface_b_l);
     double get_surface_b_l(int i_deriv);
     void set_g_1(int i_layer, double g);
     void set_g_n(double *g);
     double get_g(int i_layer);
     void set_g_l_11(int i_layer, int i_deriv, double g_l);
     void set_g_l_n1(int i_deriv, double *g_l);
     void set_g_l_1n(int i_layer, double *g_l);
     void set_g_l_nn(double **g_l);
     double get_g_l(int i_layer, int i_deriv);
     void set_coef_1(int i_layer, int n_coef_layer, double **coef);
     void set_coef_n(int *n_coef_layer, double ***coef);
     int get_n_coef(int i_layer);
     double get_coef(int i_layer, int i_elem, int i_coef);
     void set_coef_l_11(int i_layer, int i_deriv, double **coef_l);
     void set_coef_l_n1(int i_deriv, double ***coef_l);
     void set_coef_l_1n(int i_layer, double ***coef_l);
     void set_coef_l_nn(double ****coef_l);
     double get_coef_l(int i_layer, int i_deriv, int i_elem, int i_coef);
     void set_omega_1(int i_layer, double omega);
     void set_omega_n(double *omega);
     double get_omega(int i_layer);
     void set_omega_l_11(int i_layer, int i_deriv, double omega_l);
     void set_omega_l_n1(int i_deriv, double *omega_l);
     void set_omega_l_1n(int i_layer, double *omega_l);
     void set_omega_l_nn(double **omega_l);
     double get_omega_l(int i_layer, int i_deriv);
     void set_ltau_1(int i_layer, double ltau);
     void set_ltau_n(double *ltau);
     double get_ltau(int i_layer);
     void set_ltau_l_11(int i_layer, int i_deriv, double ltau_l);
     void set_ltau_l_n1(int i_deriv, double *ltau_l);
     void set_ltau_l_1n(int i_layer, double *ltau_l);
     void set_ltau_l_nn(double **ltau_l);
     double get_ltau_l(int i_layer, int i_deriv);
     void set_kernel_ampfac(int i_kernel, double ampfac);
     double get_kernel_ampfac(int i_kernel);
     void set_kernel_params_1(int i_kernel, int i_param, double param);
     void set_kernel_params_n(int i_kernel, double *params);
     double get_kernel_params(int i_kernel, int i_param);
     void set_kernel_ampfac_l_1(int i_kernel, int i_deriv, double ampfac_l);
     void set_kernel_ampfac_l_n(int i_kernel, double *ampfac_l);
     double get_kernel_ampfac_l(int i_kernel, int i_deriv);
     void set_kernel_params_l_11(int i_kernel, int i_deriv, int i_param, double param_l);
     void set_kernel_params_l_1n(int i_kernel, int i_deriv, double *params_l);
     void set_kernel_params_l_n1(int i_kernel, int i_param, double *params_l);
     void set_kernel_params_l_nn(int i_kernel, double **params_l);
     double get_kernel_params_l(int i_kernel, int i_deriv, int i_param);
     void update_varied_layers();
     void qx(double *qx);
     void qw(double *qw);
     void kernel_qx(double *kernel_qx);
     void kernel_qw(double *kernel_qw);
     void solution(solver_mask solver, int solutions, int n_out_phis, double **out_phis, double ****I_p, double ****I_m, double *****K_p, double *****K_m, double *mean_p, double *mean_m, double **mean_p_l, double **mean_m_l, double *flux_p, double *flux_m, double **flux_p_l, double **flux_m_l, double *flux_div, double **flux_div_l);
     void radiance(solver_mask solver, int n_out_phis, double **out_phis, double ****I_p, double ****I_m, double *****K_p, double *****K_m);
     void mean_radiance(solver_mask solver, double *mean_p, double *mean_m, double **mean_p_l, double **mean_m_l);
     void flux(solver_mask solver, double *flux_p, double *flux_m, double **flux_p_l, double **flux_m_l);
     void flux_divergence(solver_mask solver, double *flux_div, double **flux_div_l);
};

#endif /* XRTM_INT_CPP_H */
